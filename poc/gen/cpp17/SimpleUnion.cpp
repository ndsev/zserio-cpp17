/**
 * Automatically generated by Zserio C++17 generator version 0.1.0 using Zserio core 2.14.1.
 * Generator setup: stdAllocator.
 */

#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/SizeConvertUtil.h>
#include <zserio/UnionCaseException.h>

#include <SimpleUnion.h>

bool operator==(const SimpleUnion& lhs, const SimpleUnion& rhs)
{
    return static_cast<const SimpleUnion::Base&>(lhs) == static_cast<const SimpleUnion::Base&>(rhs);
}

bool operator<(const SimpleUnion& lhs, const SimpleUnion&  rhs)
{
    return static_cast<const SimpleUnion::Base&>(lhs) < static_cast<const SimpleUnion::Base&>(rhs);
}

bool operator!=(const SimpleUnion& lhs, const SimpleUnion& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const SimpleUnion& lhs, const SimpleUnion& rhs)
{
    return rhs < lhs;
}

bool operator<=(const SimpleUnion& lhs, const SimpleUnion& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const SimpleUnion& lhs, const SimpleUnion& rhs)
{
    return !(lhs < rhs);
}

namespace zserio
{

View<SimpleUnion>::View(const SimpleUnion& data) noexcept :
        m_data(data)
{}

SimpleUnion::ChoiceTag View<SimpleUnion>::zserioChoiceTag() const
{
    return m_data.index();
}

::std::string_view View<SimpleUnion>::valueA() const
{
    return ::std::string_view{get<SimpleUnion::ChoiceTag::CHOICE_valueA>(m_data)};
}

::zserio::Int8 View<SimpleUnion>::valueB() const
{
    return get<SimpleUnion::ChoiceTag::CHOICE_valueB>(m_data);
}

bool operator==(const View<SimpleUnion>& lhs, const View<SimpleUnion>& rhs)
{
    if (lhs.zserioChoiceTag() != rhs.zserioChoiceTag())
    {
        return false;
    }

    switch (lhs.zserioChoiceTag())
    {
    case SimpleUnion::ChoiceTag::CHOICE_valueA:
        return (lhs.valueA() == rhs.valueA());
    case SimpleUnion::ChoiceTag::CHOICE_valueB:
        return (lhs.valueB() == rhs.valueB());
    default:
        throw CppRuntimeException("No case set in union SimpleUnion!");
    }
}

bool operator<(const View<SimpleUnion>& lhs, const View<SimpleUnion>& rhs)
{
    if (lhs.zserioChoiceTag() != rhs.zserioChoiceTag())
    {
        return lhs.zserioChoiceTag() < rhs.zserioChoiceTag();
    }

    switch (lhs.zserioChoiceTag())
    {
    case SimpleUnion::ChoiceTag::CHOICE_valueA:
        return (lhs.valueA() < rhs.valueA());
    case SimpleUnion::ChoiceTag::CHOICE_valueB:
        return (lhs.valueB() < rhs.valueB());
    default:
        throw CppRuntimeException("No case set in union SimpleUnion!");
    }
}

bool operator!=(const View<SimpleUnion>& lhs, const View<SimpleUnion>& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const View<SimpleUnion>& lhs, const View<SimpleUnion>& rhs)
{
    return rhs < lhs;
}

bool operator<=(const View<SimpleUnion>& lhs, const View<SimpleUnion>& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const View<SimpleUnion>& lhs, const View<SimpleUnion>& rhs)
{
    return !(lhs < rhs);
}

namespace detail
{

template <>
void validate(const View<SimpleUnion>& view)
{
    switch (view.zserioChoiceTag())
    {
    case SimpleUnion::ChoiceTag::CHOICE_valueA:
        break;
    case SimpleUnion::ChoiceTag::CHOICE_valueB:
        // check range
        validate(view.valueB(), "'SimpleUnion.valueB'");
        break;
    default:
        throw UnionCaseException("No case set in union 'SimpleUnion'!");
    }
}

template <>
BitSize bitSizeOf(const View<SimpleUnion>& view, BitSize bitPosition)
{
    BitSize endBitPosition = bitPosition;
    endBitPosition += bitSizeOf(fromCheckedValue<VarSize>(convertSizeToUInt32(view.zserioChoiceTag())));
    switch (view.zserioChoiceTag())
    {
    case SimpleUnion::ChoiceTag::CHOICE_valueA:
        endBitPosition += bitSizeOf(view.valueA(), endBitPosition);
        break;
    case SimpleUnion::ChoiceTag::CHOICE_valueB:
        endBitPosition += bitSizeOf(view.valueB(), endBitPosition);
        break;
    default:
        throw CppRuntimeException("No case set in union SimpleUnion!");
    }

    return endBitPosition - bitPosition;
}

template <>
void write(BitStreamWriter& writer, const View<SimpleUnion>& view)
{
    write(writer, fromCheckedValue<VarSize>(convertSizeToUInt32(view.zserioChoiceTag()) - 1));
    switch (view.zserioChoiceTag())
    {
    case SimpleUnion::ChoiceTag::CHOICE_valueA:
        write(writer, view.valueA());
        break;
    case SimpleUnion::ChoiceTag::CHOICE_valueB:
        write(writer, view.valueB());
        break;
    default:
        throw CppRuntimeException("No case set in union SimpleUnion!");
    }
}

template <>
View<SimpleUnion> read(BitStreamReader& reader, SimpleUnion& data)
{
    View<SimpleUnion> view(data);

    VarSize choiceTag;
    read(reader, choiceTag);
    switch (static_cast<SimpleUnion::ChoiceTag>(choiceTag + 1))
    {
    case SimpleUnion::ChoiceTag::CHOICE_valueA:
        data.emplace<SimpleUnion::ChoiceTag::CHOICE_valueA>();
        read(reader, data.get<SimpleUnion::ChoiceTag::CHOICE_valueA>());
        break;
    case SimpleUnion::ChoiceTag::CHOICE_valueB:
        data.emplace<SimpleUnion::ChoiceTag::CHOICE_valueB>();
        read(reader, data.get<SimpleUnion::ChoiceTag::CHOICE_valueB>());
        break;
    default:
        throw CppRuntimeException("No case set in union SimpleUnion!");
    }

    return view;
}

} // namespace detail

} // namespace zserio

namespace std
{

size_t hash<SimpleUnion>::operator()(const SimpleUnion& value) const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, static_cast<const SimpleUnion::Base&>(value));
    return static_cast<size_t>(result);
}

size_t hash<::zserio::View<SimpleUnion>>::operator()(const ::zserio::View<SimpleUnion>& view) const
{
    uint32_t result = ::zserio::HASH_SEED;
    switch (view.zserioChoiceTag())
    {
    case SimpleUnion::ChoiceTag::CHOICE_valueA:
        result = ::zserio::calcHashCode(result, view.valueA());
        break;
    case SimpleUnion::ChoiceTag::CHOICE_valueB:
        result = ::zserio::calcHashCode(result, view.valueB());
        break;
    default:
        throw ::zserio::CppRuntimeException("No case set in union SimpleUnion!");
    }

    return static_cast<size_t>(result);
}

} // namespace std
