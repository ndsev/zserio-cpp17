/**
 * Automatically generated by Zserio C++17 generator version 0.1.0 using Zserio core 2.14.1.
 * Generator setup: stdAllocator.
 */

#include <zserio/ChoiceCaseException.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>

#include <BoolParamChoice.h>

bool operator==(const BoolParamChoice& lhs, const BoolParamChoice& rhs)
{
    return static_cast<const BoolParamChoice::Base&>(lhs) == static_cast<const BoolParamChoice::Base&>(rhs);
}

bool operator<(const BoolParamChoice& lhs, const BoolParamChoice&  rhs)
{
    return static_cast<const BoolParamChoice::Base&>(lhs) < static_cast<const BoolParamChoice::Base&>(rhs);
}

bool operator!=(const BoolParamChoice& lhs, const BoolParamChoice& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const BoolParamChoice& lhs, const BoolParamChoice& rhs)
{
    return rhs < lhs;
}

bool operator<=(const BoolParamChoice& lhs, const BoolParamChoice& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const BoolParamChoice& lhs, const BoolParamChoice& rhs)
{
    return !(lhs < rhs);
}

namespace zserio
{

View<BoolParamChoice>::View(const BoolParamChoice& data,
        ::zserio::Bool tag_) noexcept :
        m_data(data),
        m_tag_(tag_)
{}

::zserio::Bool View<BoolParamChoice>::tag() const
{
    return m_tag_;
}

BoolParamChoice::ChoiceTag View<BoolParamChoice>::zserioChoiceTag() const
{
    return m_data.index();
}

::zserio::Int8 View<BoolParamChoice>::valueA() const
{
    return get<BoolParamChoice::ChoiceTag::CHOICE_valueA>(m_data);
}

::zserio::Int16 View<BoolParamChoice>::valueB() const
{
    return get<BoolParamChoice::ChoiceTag::CHOICE_valueB>(m_data);
}

bool operator==(const View<BoolParamChoice>& lhs, const View<BoolParamChoice>& rhs)
{
    if (lhs.tag() != rhs.tag())
    {
        return false;
    }

    if ((lhs.tag()) == false)
    {
        return (lhs.valueA() == rhs.valueA());
    }
    else
    {
        return (lhs.valueB() == rhs.valueB());
    }
}

bool operator<(const View<BoolParamChoice>& lhs, const View<BoolParamChoice>& rhs)
{
    if (lhs.tag() != rhs.tag())
    {
        return lhs.tag() < rhs.tag();
    }

    if ((lhs.tag()) == false)
    {
        return (lhs.valueA() < rhs.valueA());
    }
    else
    {
        return (lhs.valueB() < rhs.valueB());
    }
}

bool operator!=(const View<BoolParamChoice>& lhs, const View<BoolParamChoice>& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const View<BoolParamChoice>& lhs, const View<BoolParamChoice>& rhs)
{
    return rhs < lhs;
}

bool operator<=(const View<BoolParamChoice>& lhs, const View<BoolParamChoice>& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const View<BoolParamChoice>& lhs, const View<BoolParamChoice>& rhs)
{
    return !(lhs < rhs);
}

namespace detail
{

template <>
void validate(const View<BoolParamChoice>& view)
{
    if ((view.tag()) == false)
    {
        // check choice case
        if (view.zserioChoiceTag() != BoolParamChoice::ChoiceTag::CHOICE_valueA)
        {
            throw ChoiceCaseException("Wrong case set in choice 'BoolParamChoice' (") << static_cast<size_t>(view.zserioChoiceTag()) <<
                    " != " << static_cast<size_t>(BoolParamChoice::ChoiceTag::CHOICE_valueA) << ")!";
        }
        // check range
        validate(view.valueA(), "'BoolParamChoice.valueA'");
    }
    else
    {
        // check choice case
        if (view.zserioChoiceTag() != BoolParamChoice::ChoiceTag::CHOICE_valueB)
        {
            throw ChoiceCaseException("Wrong case set in choice 'BoolParamChoice' (") << static_cast<size_t>(view.zserioChoiceTag()) <<
                    " != " << static_cast<size_t>(BoolParamChoice::ChoiceTag::CHOICE_valueB) << ")!";
        }
        // check range
        validate(view.valueB(), "'BoolParamChoice.valueB'");
    }
}

template <>
BitSize bitSizeOf(const View<BoolParamChoice>& view, BitSize bitPosition)
{
    BitSize endBitPosition = bitPosition;
    if ((view.tag()) == false)
    {
        endBitPosition += bitSizeOf(view.valueA(), endBitPosition);
    }
    else
    {
        endBitPosition += bitSizeOf(view.valueB(), endBitPosition);
    }

    return endBitPosition - bitPosition;
}

template <>
void write(BitStreamWriter& writer, const View<BoolParamChoice>& view)
{
    if ((view.tag()) == false)
    {
        write(writer, view.valueA());
    }
    else
    {
        write(writer, view.valueB());
    }
}

template <>
View<BoolParamChoice> read(BitStreamReader& reader, BoolParamChoice& data,
        ::zserio::Bool tag_)
{
    View<BoolParamChoice> view(data,
            tag_);
    if ((view.tag()) == false)
    {
        data.emplace<BoolParamChoice::ChoiceTag::CHOICE_valueA>();
        read(reader, data.get<BoolParamChoice::ChoiceTag::CHOICE_valueA>());
    }
    else
    {
        data.emplace<BoolParamChoice::ChoiceTag::CHOICE_valueB>();
        read(reader, data.get<BoolParamChoice::ChoiceTag::CHOICE_valueB>());
    }

    return view;
}

} // namespace detail

} // namespace zserio

namespace std
{

size_t hash<BoolParamChoice>::operator()(const BoolParamChoice& value) const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, static_cast<const BoolParamChoice::Base&>(value));
    return static_cast<size_t>(result);
}

size_t hash<::zserio::View<BoolParamChoice>>::operator()(const ::zserio::View<BoolParamChoice>& view) const
{
    uint32_t result = ::zserio::HASH_SEED;
    if ((view.tag()) == false)
    {
        result = ::zserio::calcHashCode(result, view.valueA());
    }
    else
    {
        result = ::zserio::calcHashCode(result, view.valueB());
    }

    return static_cast<size_t>(result);
}

} // namespace std
