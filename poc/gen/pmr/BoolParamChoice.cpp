/**
 * Automatically generated by Zserio C++ generator version 1.0.1 using Zserio core 2.14.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, stdAllocator.
 */

#include "BoolParamChoice.h"

namespace pmr
{

BoolParamChoice::BoolParamChoice() noexcept :
        BoolParamChoice(allocator_type())
{}

BoolParamChoice::BoolParamChoice(const allocator_type& allocator) noexcept
//: objectChoice(allocator)
{}

bool operator==(const BoolParamChoice& lhs, const BoolParamChoice& rhs)
{
    return lhs.objectChoice == rhs.objectChoice;
}

bool operator<(const BoolParamChoice& lhs, const BoolParamChoice& rhs)
{
    return lhs.objectChoice < rhs.objectChoice;
}

bool operator!=(const BoolParamChoice& lhs, const BoolParamChoice& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const BoolParamChoice& lhs, const BoolParamChoice& rhs)
{
    return rhs < lhs;
}

bool operator<=(const BoolParamChoice& lhs, const BoolParamChoice& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const BoolParamChoice& lhs, const BoolParamChoice& rhs)
{
    return !(lhs < rhs);
}

} // namespace pmr

namespace zserio
{

View<::pmr::BoolParamChoice>::View(const ::pmr::BoolParamChoice& data, ::zserio::Boolean tag_) noexcept :
        m_tag_(tag_),
        m_data(data)
{}

::zserio::Boolean View<::pmr::BoolParamChoice>::tag() const
{
    return m_tag_;
}

::pmr::BoolParamChoice::ChoiceTag View<::pmr::BoolParamChoice>::index() const
{
    return static_cast<::pmr::BoolParamChoice::ChoiceTag>(m_data.objectChoice.index());
}

::zserio::Int8 View<::pmr::BoolParamChoice>::valueA() const
{
    return m_data.objectChoice.get<::pmr::BoolParamChoice::VALUE_A_IDX>();
}

::zserio::Int16 View<::pmr::BoolParamChoice>::valueB() const
{
    return m_data.objectChoice.get<::pmr::BoolParamChoice::VALUE_B_IDX>();
}

bool operator==(const View<::pmr::BoolParamChoice>& lhs, const View<::pmr::BoolParamChoice>& rhs)
{
    if (lhs.index() != rhs.index())
        return false;

    switch (lhs.index())
    {
    case ::pmr::BoolParamChoice::VALUE_A_IDX:
        return lhs.valueA() == rhs.valueA();
    default:
        return lhs.valueB() == rhs.valueB();
    }
}

bool operator<(const View<::pmr::BoolParamChoice>& lhs, const View<::pmr::BoolParamChoice>& rhs)
{
    if (lhs.index() < rhs.index())
        return true;
    if (rhs.index() < lhs.index())
        return false;

    switch (lhs.index())
    {
    case ::pmr::BoolParamChoice::VALUE_A_IDX:
        return lhs.valueA() < rhs.valueA();
    default:
        return lhs.valueB() < rhs.valueB();
    }
}

bool operator!=(const View<::pmr::BoolParamChoice>& lhs, const View<::pmr::BoolParamChoice>& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const View<::pmr::BoolParamChoice>& lhs, const View<::pmr::BoolParamChoice>& rhs)
{
    return rhs < lhs;
}

bool operator<=(const View<::pmr::BoolParamChoice>& lhs, const View<::pmr::BoolParamChoice>& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const View<::pmr::BoolParamChoice>& lhs, const View<::pmr::BoolParamChoice>& rhs)
{
    return !(lhs < rhs);
}

namespace detail
{

template <>
void validate(const View<::pmr::BoolParamChoice>& view)
{
    ::pmr::BoolParamChoice::ChoiceTag idx;
    switch (view.tag())
    {
    case false:
        idx = ::pmr::BoolParamChoice::VALUE_A_IDX;
        break;
    default:
        idx = ::pmr::BoolParamChoice::VALUE_B_IDX;
        break;
    }

    if (idx != view.index())
    {
        throw ::zserio::CppRuntimeException("Write: Wrong choice variant stored for ::pmr::BoolParamChoice: ")
                << static_cast<size_t>(idx) << " != " << static_cast<size_t>(view.index()) << "!";
    }
}

template <>
void write(::zserio::BitStreamWriter& writer, const View<::pmr::BoolParamChoice>& view)
{
    switch (view.tag())
    {
    case false:
        detail::write(writer, view.valueA());
        break;
    default:
        detail::write(writer, view.valueB());
        break;
    }
}

View<::pmr::BoolParamChoice> readImpl(::zserio::BitStreamReader& reader, ::pmr::BoolParamChoice& data,
        const ::pmr::BoolParamChoice::allocator_type& allocator, ::zserio::Boolean tag_)
{
    View<::pmr::BoolParamChoice> view(data, tag_);

    switch (view.tag())
    {
    case false:
        data.objectChoice.emplace<::pmr::BoolParamChoice::VALUE_A_IDX>();
        detail::read(reader, data.objectChoice.get<::pmr::BoolParamChoice::VALUE_A_IDX>());
        break;
    default:
        data.objectChoice.emplace<::pmr::BoolParamChoice::VALUE_B_IDX>();
        detail::read(reader, data.objectChoice.get<::pmr::BoolParamChoice::VALUE_B_IDX>());
        break;
    }

    return view;
}

template <>
size_t bitSizeOf(const View<::pmr::BoolParamChoice>& view, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    switch (view.tag())
    {
    case false:
        endBitPosition += detail::bitSizeOf(view.valueA(), endBitPosition);
        break;
    default:
        endBitPosition += detail::bitSizeOf(view.valueB(), endBitPosition);
        break;
    }

    return endBitPosition - bitPosition;
}

} // namespace detail

} // namespace zserio

namespace std
{

size_t hash<::pmr::BoolParamChoice>::operator()(const ::pmr::BoolParamChoice& data) const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, data.objectChoice);
    return result;
}

size_t hash<::zserio::View<::pmr::BoolParamChoice>>::operator()(
        const ::zserio::View<::pmr::BoolParamChoice>& view) const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, static_cast<size_t>(view.index()));

    switch (view.tag())
    {
    case false:
        result = ::zserio::calcHashCode(result, view.valueA());
        break;
    default:
        result = ::zserio::calcHashCode(result, view.valueB());
        break;
    }
    return result;
}

} // namespace std
