/**
 * Automatically generated by Zserio C++ generator version 1.0.0 using Zserio core 2.13.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, stdAllocator.
 */

#ifndef PMR_LINE_POSITION_CONTAINER_H
#define PMR_LINE_POSITION_CONTAINER_H

#include <zserio/CppRuntimeVersion.h>
#if CPP_EXTENSION_RUNTIME_VERSION_NUMBER != 1000000
    #error Version mismatch between Zserio runtime library and Zserio C++ generator!
    #error Please update your Zserio runtime library to the version 1.0.0.
#endif

#include <pmr/CoordShift.h>
#include <tuple>
#include <zserio/AllocatorPropagatingCopy.h>
#include <zserio/Array.h>
#include <zserio/ArrayTraits.h>
#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/TypeWrappers.h>
#include <zserio/View.h>
#include <zserio/pmr/PolymorphicAllocator.h>
#include <zserio/pmr/Vector.h>

// here we explore a different idea for View as Data<T>::View comes with lots
// of problems. Compiler is not able to deduce such view so all function calls
// need to carry explitit type such as operator==<T>(view1, view2). You can't
// even store views in std::unordered/map without extra comparator.

namespace pmr
{

template <typename T, typename U>
struct PositionContainer
{
    using allocator_type = ::zserio::pmr::PropagatingPolymorphicAllocator<>;
    using needs_initialize_offsets =
            ::std::disjunction<typename U::needs_initialize_offsets, typename T::needs_initialize_offsets>;

    struct ZserioPackingContext
    {
        ::zserio::VarSize::ZserioPackingContext numElements;
        typename U::ZserioPackingContext field;
    };

    //-------------------------------------

    PositionContainer() noexcept :
            PositionContainer(allocator_type())
    {}

    explicit PositionContainer(const allocator_type& allocator) :
            array(allocator),
            field(allocator)
    {}

    PositionContainer(::zserio::VarSize numElements_, ::zserio::pmr::vector<T> array_, U field_) :
            numElements(::std::move(numElements_)),
            array(::std::move(array_)),
            field(::std::move(field_))
    {}

    ::zserio::VarSize numElements;
    ::zserio::pmr::vector<T> array;
    U field;
};

template <typename T, typename U>
bool operator==(const PositionContainer<T, U>& lhs, const PositionContainer<T, U>& rhs)
{
    return ::std::tie(lhs.numElements, lhs.array, lhs.field) ==
            ::std::tie(rhs.numElements, rhs.array, rhs.field);
}

template <typename T, typename U>
bool operator<(const PositionContainer<T, U>& lhs, const PositionContainer<T, U>& rhs)
{
    return ::std::tie(lhs.numElements, lhs.array, lhs.field) <
            ::std::tie(rhs.numElements, rhs.array, rhs.field);
}

template <typename T, typename U>
bool operator!=(const PositionContainer<T, U>& lhs, const PositionContainer<T, U>& rhs)
{
    return !(lhs == rhs);
}

template <typename T, typename U>
bool operator>(const PositionContainer<T, U>& lhs, const PositionContainer<T, U>& rhs)
{
    return rhs < lhs;
}

template <typename T, typename U>
bool operator<=(const PositionContainer<T, U>& lhs, const PositionContainer<T, U>& rhs)
{
    return !(rhs < lhs);
}

template <typename T, typename U>
bool operator>=(const PositionContainer<T, U>& lhs, const PositionContainer<T, U>& rhs)
{
    return !(lhs < rhs);
}

} // namespace pmr

namespace zserio
{

template <typename T, typename U>
class View<::pmr::PositionContainer<T, U>>
{
public:
    struct ZserioArrayTraits_array : ::zserio::ArrayTraitsBase<View, T>
    {
        using Base = ::zserio::ArrayTraitsBase<View, T>; // msvc needs this to resolve types
        using ElementType = typename Base::ElementType;

        static typename Base::ViewType at(
                const typename Base::OwnerType& owner, const ElementType& element, size_t index)
        {
            return typename Base::ViewType(element, owner.shift());
        }
        static void read(const typename Base::OwnerType& owner, ::zserio::pmr::vector<ElementType>& array,
                ::zserio::BitStreamReader& in, size_t index)
        {
            array.emplace_back(array.get_allocator());
            detail::read(in, array.back(), array.get_allocator(), owner.shift());
        }
        static void write(const typename Base::OwnerType& owner, ::zserio::BitStreamWriter& out,
                const ElementType& element, size_t index)
        {
            detail::write(out, at(owner, element, index));
        }
        static size_t bitSizeOf(const typename Base::OwnerType& owner, size_t endBitPosition,
                const ElementType& element, size_t index)
        {
            return detail::bitSizeOf(at(owner, element, index), endBitPosition);
        }
    };

    using ZserioArrayType_array =
            ::zserio::Array<::zserio::pmr::vector<T>, ZserioArrayTraits_array, ::zserio::ArrayType::NORMAL>;

    View(const ::pmr::PositionContainer<T, U>& data, ::pmr::CoordShift shift_) noexcept :
            m_shift_(shift_),
            m_data(data)
    {}

    ::pmr::CoordShift shift() const
    {
        return m_shift_;
    }

    ::zserio::VarSize numElements() const
    {
        return m_data.numElements;
    }

    // Array should probably copy the View (owner) into it so dangling references
    // will be prevented
    const ZserioArrayType_array array() const
    {
        return ZserioArrayType_array(*this, m_data.array);
    }

    U field() const
    {
        return m_data.field;
    }

private:
    const ::pmr::PositionContainer<T, U>& m_data;
    ::pmr::CoordShift m_shift_;
};

template <typename T, typename U>
bool operator==(const ::zserio::View<::pmr::PositionContainer<T, U>>& lhs,
        const ::zserio::View<::pmr::PositionContainer<T, U>>& rhs)
{
    if (&lhs != &rhs)
    {
        return lhs.numElements() == rhs.numElements() && lhs.array() == rhs.array();
    }

    return true;
}

template <typename T, typename U>
bool operator<(const ::zserio::View<::pmr::PositionContainer<T, U>>& lhs,
        const ::zserio::View<::pmr::PositionContainer<T, U>>& rhs)
{
    if (lhs.numElements() != rhs.numElements())
        return lhs.numElements() < rhs.numElements();
    if (lhs.array() != rhs.array())
        return lhs.array() < rhs.array();

    return false;
}

template <typename T, typename U>
bool operator!=(const ::zserio::View<::pmr::PositionContainer<T, U>>& lhs,
        const ::zserio::View<::pmr::PositionContainer<T, U>>& rhs)
{
    return !(lhs == rhs);
}

template <typename T, typename U>
bool operator>(const ::zserio::View<::pmr::PositionContainer<T, U>>& lhs,
        const ::zserio::View<::pmr::PositionContainer<T, U>>& rhs)
{
    return rhs < lhs;
}

template <typename T, typename U>
bool operator<=(const ::zserio::View<::pmr::PositionContainer<T, U>>& lhs,
        const ::zserio::View<::pmr::PositionContainer<T, U>>& rhs)
{
    return !(rhs < lhs);
}

template <typename T, typename U>
bool operator>=(const ::zserio::View<::pmr::PositionContainer<T, U>>& lhs,
        const ::zserio::View<::pmr::PositionContainer<T, U>>& rhs)
{
    return !(lhs < rhs);
}

namespace detail
{

template <typename T, typename U>
void validate(const ::zserio::View<::pmr::PositionContainer<T, U>>& view)
{
    // todo view.array().validate();
    detail::validate(view.field());
}

template <typename T, typename U>
void write(::zserio::BitStreamWriter& writer, const ::zserio::View<::pmr::PositionContainer<T, U>>& view)
{
    detail::write(writer, view.numElements());
    view.array().write(writer);
    detail::write(writer, view.field());
}

template <typename T, typename U>
void write(::zserio::BitStreamWriter& writer,
        typename ::pmr::PositionContainer<T, U>::ZserioPackingContext& context,
        const ::zserio::View<::pmr::PositionContainer<T, U>>& view)
{
    detail::write(writer, context.numElements, view.numElements());

    view.array().write(writer);

    detail::write(writer, context.field, view.field());
}

template <typename T, typename U>
::zserio::View<::pmr::PositionContainer<T, U>> read(::zserio::BitStreamReader& reader,
        ::pmr::PositionContainer<T, U>& data,
        const typename ::pmr::PositionContainer<T, U>::allocator_type& allocator, ::pmr::CoordShift shift_)
{
    typename ::zserio::View<::pmr::PositionContainer<T, U>> view(data, shift_);

    detail::read(reader, data.numElements);

    typename ::zserio::View<::pmr::PositionContainer<T, U>>::ZserioArrayType_array(
            view, data.array, reader, view.numElements());

    detail::read(reader, data.field);

    return view;
}

template <typename T, typename U>
::zserio::View<::pmr::PositionContainer<T, U>> read(::zserio::BitStreamReader& reader,
        typename ::pmr::PositionContainer<T, U>::ZserioPackingContext& context,
        ::pmr::PositionContainer<T, U>& data,
        const typename ::pmr::PositionContainer<T, U>::allocator_type& allocator, ::pmr::CoordShift shift_)
{
    ::zserio::View<::pmr::PositionContainer<T, U>> view(data, shift_);

    detail::read(reader, context.numElements, data.numElements);

    typename ::zserio::View<::pmr::PositionContainer<T, U>>::ZserioArrayType_array(
            view, data.array, reader, view.numElements());

    detail::read(reader, context.field, data.field, allocator);

    return view;
}

template <typename T, typename U>
size_t bitSizeOf(const ::zserio::View<::pmr::PositionContainer<T, U>>& view, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += detail::bitSizeOf(view.numElements(), endBitPosition);
    endBitPosition += view.array().bitSizeOf(endBitPosition);
    endBitPosition += detail::bitSizeOf(view.field(), endBitPosition);

    return endBitPosition - bitPosition;
}

template <typename T, typename U>
size_t bitSizeOf(const ::zserio::View<::pmr::PositionContainer<T, U>>& view,
        typename ::pmr::PositionContainer<T, U>::ZserioPackingContext& context, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += detail::bitSizeOf(view.numElements(), context.numElements, endBitPosition);
    endBitPosition += view.array().bitSizeOf(endBitPosition);
    endBitPosition += detail::bitSizeOf(view.field(), context.field, endBitPosition);

    return endBitPosition - bitPosition;
}

template <typename T, typename U,
        typename = ::std::enable_if_t<::pmr::PositionContainer<T, U>::needs_initialize_offsets::value>>
size_t initializeOffsets(::pmr::PositionContainer<T, U>& data, size_t endBitPosition, ::pmr::CoordShift shift)
{
    typename ::zserio::View<::pmr::PositionContainer<T, U>> view(data, shift);

    endBitPosition += detail::bitSizeOf(view.numElements(), endBitPosition);
    // todo: endBitPosition = view.array().initializeOffsets(endBitPosition);
    endBitPosition += view.array().bitSizeOf(endBitPosition);
    if constexpr (U::needs_initialize_offsets::value)
        endBitPosition = detail::initializeOffsets(data.field, endBitPosition);
    else
        endBitPosition += detail::bitSizeOf(view.field(), endBitPosition);
    return endBitPosition;
}

template <typename T, typename U>
void initPackingContext(const ::zserio::View<::pmr::PositionContainer<T, U>>& view,
        typename ::pmr::PositionContainer<T, U>::ZserioPackingContext& context)
{
    detail::initPackingContext(view.numElements(), context.numElements);

    detail::initPackingContext(view.field(), context.field);
}

} // namespace detail

} // namespace zserio

namespace std
{

template <typename T, typename U>
struct hash<::pmr::PositionContainer<T, U>>
{
    size_t operator()(const ::pmr::PositionContainer<T, U>& data) const
    {
        uint32_t result = ::zserio::HASH_SEED;

        result = ::zserio::calcHashCode(result, data.numElements);
        result = ::zserio::calcHashCode(result, data.array);
        result = ::zserio::calcHashCode(result, data.field);

        return result;
    }
};

template <typename T, typename U>
struct hash<::zserio::View<::pmr::PositionContainer<T, U>>>
{
    size_t operator()(const ::zserio::View<::pmr::PositionContainer<T, U>>& view) const
    {
        uint32_t result = ::zserio::HASH_SEED;

        result = ::zserio::calcHashCode(result, view.numElements());
        result = ::zserio::calcHashCode(result, view.array());
        result = ::zserio::calcHashCode(result, view.field());

        return result;
    }
};

} // namespace std

#endif // LINE_POSITION_OFFSET2_D_H
