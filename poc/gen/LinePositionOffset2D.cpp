/**
 * Automatically generated by Zserio C++ generator version 1.0.0 using Zserio core 2.13.0.
 * Generator setup: writerCode, pubsubCode, serviceCode, sqlCode, stdAllocator.
 */

#include "LinePositionOffset2D.h"

LinePositionOffset2D::LinePositionOffset2D() noexcept :
        LinePositionOffset2D(allocator_type())
{}

LinePositionOffset2D::LinePositionOffset2D(const allocator_type& allocator) :
        offset(allocator)
{}

LinePositionOffset2D::LinePositionOffset2D(
        LinePosition linePosition_, CoordWidth numBits_, PositionOffset2D offset_) :
        linePosition(::std::move(linePosition_)),
        numBits(::std::move(numBits_)),
        offset(::std::move(offset_))
{}

bool operator==(const LinePositionOffset2D& lhs, const LinePositionOffset2D& rhs)
{
    return ::std::tie(lhs.linePosition, lhs.numBits, lhs.offset) ==
            ::std::tie(rhs.linePosition, rhs.numBits, rhs.offset);
}

bool operator<(const LinePositionOffset2D& lhs, const LinePositionOffset2D& rhs)
{
    return ::std::tie(lhs.linePosition, lhs.numBits, lhs.offset) <
            ::std::tie(rhs.linePosition, rhs.numBits, rhs.offset);
}

bool operator!=(const LinePositionOffset2D& lhs, const LinePositionOffset2D& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const LinePositionOffset2D& lhs, const LinePositionOffset2D& rhs)
{
    return rhs < lhs;
}

bool operator<=(const LinePositionOffset2D& lhs, const LinePositionOffset2D& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const LinePositionOffset2D& lhs, const LinePositionOffset2D& rhs)
{
    return !(lhs < rhs);
}

namespace zserio
{

View<LinePositionOffset2D>::View(const LinePositionOffset2D& data, CoordShift shift_) noexcept :
        m_shift_(shift_),
        m_data(data)
{}

CoordShift View<LinePositionOffset2D>::shift() const
{
    return m_shift_;
}

LinePosition View<LinePositionOffset2D>::linePosition() const
{
    return m_data.linePosition;
}

CoordWidth View<LinePositionOffset2D>::numBits() const
{
    return m_data.numBits;
}

// we need to generate this code for each compound field to transport parameters correctly
View<PositionOffset2D> View<LinePositionOffset2D>::offset() const
{
    return View<PositionOffset2D>(m_data.offset, m_data.numBits, m_shift_);
}

bool operator==(const View<LinePositionOffset2D>& lhs, const View<LinePositionOffset2D>& rhs)
{
    return (lhs.shift() == rhs.shift()) && (lhs.linePosition() == rhs.linePosition()) &&
            (lhs.numBits() == rhs.numBits()) && (lhs.offset() == rhs.offset());
}

bool operator<(const View<LinePositionOffset2D>& lhs, const View<LinePositionOffset2D>& rhs)
{
    if (lhs.shift() != rhs.shift())
        return lhs.shift() < rhs.shift();
    if (lhs.linePosition() != rhs.linePosition())
        return lhs.linePosition() < rhs.linePosition();
    if (lhs.numBits() != rhs.numBits())
        return lhs.numBits() < rhs.numBits();
    if (lhs.offset() != rhs.offset())
        return lhs.offset() < rhs.offset();

    return false;
}

bool operator!=(const View<LinePositionOffset2D>& lhs, const View<LinePositionOffset2D>& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const View<LinePositionOffset2D>& lhs, const View<LinePositionOffset2D>& rhs)
{
    return rhs < lhs;
}

bool operator<=(const View<LinePositionOffset2D>& lhs, const View<LinePositionOffset2D>& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const View<LinePositionOffset2D>& lhs, const View<LinePositionOffset2D>& rhs)
{
    return !(lhs < rhs);
}

namespace detail
{

template <>
void validate(const ::zserio::View<LinePositionOffset2D>& view)
{
    detail::validate(view.offset());
}

template <>
void write(::zserio::BitStreamWriter& writer, const ::zserio::View<LinePositionOffset2D>& view)
{
    detail::write(writer, view.linePosition());
    detail::write(writer, view.numBits());
    detail::write(writer, view.offset());
}

View<LinePositionOffset2D> readImpl(::zserio::BitStreamReader& reader, LinePositionOffset2D& data,
        const LinePositionOffset2D::allocator_type& allocator, CoordShift shift_)
{
    View<LinePositionOffset2D> view(data, shift_);

    detail::read(reader, data.linePosition);
    detail::read(reader, data.numBits);
    detail::read(reader, data.offset, allocator, view.numBits(), shift_);

    return view;
}

template <>
size_t bitSizeOf(const ::zserio::View<LinePositionOffset2D>& view, size_t bitPosition)
{
    size_t endBitPosition = bitPosition;

    endBitPosition += detail::bitSizeOf(view.linePosition(), endBitPosition);
    endBitPosition += detail::bitSizeOf(view.numBits(), endBitPosition);
    endBitPosition += detail::bitSizeOf(view.offset(), endBitPosition);

    return endBitPosition - bitPosition;
}

} // namespace detail

} // namespace zserio

namespace std
{

size_t hash<LinePositionOffset2D>::operator()(const LinePositionOffset2D& data) const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, data.linePosition);
    result = ::zserio::calcHashCode(result, data.numBits);
    result = ::zserio::calcHashCode(result, data.offset);

    return result;
}

size_t hash<::zserio::View<LinePositionOffset2D>>::operator()(
        const ::zserio::View<LinePositionOffset2D>& view) const
{
    uint32_t result = ::zserio::HASH_SEED;

    result = ::zserio::calcHashCode(result, view.shift());
    result = ::zserio::calcHashCode(result, view.linePosition());
    result = ::zserio::calcHashCode(result, view.numBits());
    result = ::zserio::calcHashCode(result, view.offset());

    return result;
}

} // namespace std
