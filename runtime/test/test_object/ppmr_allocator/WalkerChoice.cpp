/**
 * Automatically generated by Zserio C++17 generator version 0.4.0 using Zserio core 2.16.1.
 * Generator setup: typeInfoCode, ppmrAllocator.
 */

#include <zserio/ChoiceCaseException.h>
#include <zserio/CppRuntimeException.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/IntrospectableView.h>
#include <zserio/ReflectableData.h>
#include <zserio/ReflectableUtil.h>
#include <zserio/TypeInfo.h>

#include <test_object/ppmr_allocator/WalkerChoice.h>

namespace test_object
{
namespace ppmr_allocator
{

bool operator==(const ::test_object::ppmr_allocator::WalkerChoice& lhs, const ::test_object::ppmr_allocator::WalkerChoice& rhs)
{
    return static_cast<const ::test_object::ppmr_allocator::WalkerChoice::Base&>(lhs) == static_cast<const ::test_object::ppmr_allocator::WalkerChoice::Base&>(rhs);
}

bool operator<(const ::test_object::ppmr_allocator::WalkerChoice& lhs, const ::test_object::ppmr_allocator::WalkerChoice&  rhs)
{
    return static_cast<const ::test_object::ppmr_allocator::WalkerChoice::Base&>(lhs) < static_cast<const ::test_object::ppmr_allocator::WalkerChoice::Base&>(rhs);
}

bool operator!=(const ::test_object::ppmr_allocator::WalkerChoice& lhs, const ::test_object::ppmr_allocator::WalkerChoice& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const ::test_object::ppmr_allocator::WalkerChoice& lhs, const ::test_object::ppmr_allocator::WalkerChoice& rhs)
{
    return rhs < lhs;
}

bool operator<=(const ::test_object::ppmr_allocator::WalkerChoice& lhs, const ::test_object::ppmr_allocator::WalkerChoice& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const ::test_object::ppmr_allocator::WalkerChoice& lhs, const ::test_object::ppmr_allocator::WalkerChoice& rhs)
{
    return !(lhs < rhs);
}

} // namespace ppmr_allocator
} // namespace test_object

namespace zserio
{

View<::test_object::ppmr_allocator::WalkerChoice>::View(const ::test_object::ppmr_allocator::WalkerChoice& data,
        ::zserio::UInt8 selector_) noexcept :
        m_data(&data),
        m_selector_(selector_)
{}

View<::test_object::ppmr_allocator::WalkerChoice>::View(const ::test_object::ppmr_allocator::WalkerChoice& data,
        const View& other) noexcept :
        m_data(&data),
        m_selector_(other.selector())
{}

::zserio::UInt8 View<::test_object::ppmr_allocator::WalkerChoice>::selector() const
{
    return m_selector_;
}

::zserio::UInt8 View<::test_object::ppmr_allocator::WalkerChoice>::value8() const
{
    return get<::test_object::ppmr_allocator::WalkerChoice::Tag::value8>(*m_data);
}

::zserio::UInt16 View<::test_object::ppmr_allocator::WalkerChoice>::value16() const
{
    return get<::test_object::ppmr_allocator::WalkerChoice::Tag::value16>(*m_data);
}

::zserio::UInt32 View<::test_object::ppmr_allocator::WalkerChoice>::value32() const
{
    return get<::test_object::ppmr_allocator::WalkerChoice::Tag::value32>(*m_data);
}

::zserio::UInt64 View<::test_object::ppmr_allocator::WalkerChoice>::value64() const
{
    return get<::test_object::ppmr_allocator::WalkerChoice::Tag::value64>(*m_data);
}

::test_object::ppmr_allocator::WalkerChoice::Tag View<::test_object::ppmr_allocator::WalkerChoice>::zserioChoiceTag() const
{
    return m_data->index();
}

const ::test_object::ppmr_allocator::WalkerChoice& View<::test_object::ppmr_allocator::WalkerChoice>::zserioData() const
{
    return *m_data;
}

bool operator==(const View<::test_object::ppmr_allocator::WalkerChoice>& lhs, const View<::test_object::ppmr_allocator::WalkerChoice>& rhs)
{
    if (lhs.selector() != rhs.selector())
    {
        return false;
    }

    if (lhs.zserioChoiceTag() != rhs.zserioChoiceTag())
    {
        return false;
    }

    switch (lhs.zserioChoiceTag())
    {
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value8:
        return (lhs.value8() == rhs.value8());
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value16:
        return (lhs.value16() == rhs.value16());
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value32:
        return (lhs.value32() == rhs.value32());
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value64:
        return (lhs.value64() == rhs.value64());
    default:
        return true;
    }
}

bool operator<(const View<::test_object::ppmr_allocator::WalkerChoice>& lhs, const View<::test_object::ppmr_allocator::WalkerChoice>& rhs)
{
    if (lhs.selector() != rhs.selector())
    {
        return lhs.selector() < rhs.selector();
    }

    if (lhs.zserioChoiceTag() != rhs.zserioChoiceTag())
    {
        return lhs.zserioChoiceTag() < rhs.zserioChoiceTag();
    }

    switch (lhs.zserioChoiceTag())
    {
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value8:
        return (lhs.value8() < rhs.value8());
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value16:
        return (lhs.value16() < rhs.value16());
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value32:
        return (lhs.value32() < rhs.value32());
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value64:
        return (lhs.value64() < rhs.value64());
    default:
        return false;
    }
}

bool operator!=(const View<::test_object::ppmr_allocator::WalkerChoice>& lhs, const View<::test_object::ppmr_allocator::WalkerChoice>& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const View<::test_object::ppmr_allocator::WalkerChoice>& lhs, const View<::test_object::ppmr_allocator::WalkerChoice>& rhs)
{
    return rhs < lhs;
}

bool operator<=(const View<::test_object::ppmr_allocator::WalkerChoice>& lhs, const View<::test_object::ppmr_allocator::WalkerChoice>& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const View<::test_object::ppmr_allocator::WalkerChoice>& lhs, const View<::test_object::ppmr_allocator::WalkerChoice>& rhs)
{
    return !(lhs < rhs);
}

namespace detail
{

void ObjectTraits<::test_object::ppmr_allocator::WalkerChoice>::validate(const View<::test_object::ppmr_allocator::WalkerChoice>& view, ::std::string_view)
{
    detail::validate(view.selector(), "'WalkerChoice.selector'");
    switch (view.selector())
    {
    case 8:
        // check choice case
        if (view.zserioChoiceTag() != ::test_object::ppmr_allocator::WalkerChoice::Tag::value8)
        {
            throw ChoiceCaseException("Wrong case set in choice 'WalkerChoice' (") << static_cast<size_t>(view.zserioChoiceTag()) <<
                    " != " << static_cast<size_t>(::test_object::ppmr_allocator::WalkerChoice::Tag::value8) << ")!";
        }
        detail::validate(view.value8(), "'WalkerChoice.value8'");
        break;
    case 16:
        // check choice case
        if (view.zserioChoiceTag() != ::test_object::ppmr_allocator::WalkerChoice::Tag::value16)
        {
            throw ChoiceCaseException("Wrong case set in choice 'WalkerChoice' (") << static_cast<size_t>(view.zserioChoiceTag()) <<
                    " != " << static_cast<size_t>(::test_object::ppmr_allocator::WalkerChoice::Tag::value16) << ")!";
        }
        detail::validate(view.value16(), "'WalkerChoice.value16'");
        break;
    case 32:
        // check choice case
        if (view.zserioChoiceTag() != ::test_object::ppmr_allocator::WalkerChoice::Tag::value32)
        {
            throw ChoiceCaseException("Wrong case set in choice 'WalkerChoice' (") << static_cast<size_t>(view.zserioChoiceTag()) <<
                    " != " << static_cast<size_t>(::test_object::ppmr_allocator::WalkerChoice::Tag::value32) << ")!";
        }
        detail::validate(view.value32(), "'WalkerChoice.value32'");
        break;
    case 64:
        // check choice case
        if (view.zserioChoiceTag() != ::test_object::ppmr_allocator::WalkerChoice::Tag::value64)
        {
            throw ChoiceCaseException("Wrong case set in choice 'WalkerChoice' (") << static_cast<size_t>(view.zserioChoiceTag()) <<
                    " != " << static_cast<size_t>(::test_object::ppmr_allocator::WalkerChoice::Tag::value64) << ")!";
        }
        detail::validate(view.value64(), "'WalkerChoice.value64'");
        break;
    default:
        // empty
        if (view.zserioChoiceTag() != ::test_object::ppmr_allocator::WalkerChoice::Tag::ZSERIO_UNDEFINED)
        {
            throw ChoiceCaseException("Wrong case set in choice 'WalkerChoice' (should be empty)!");
        }
        break;
    }
}

BitSize ObjectTraits<::test_object::ppmr_allocator::WalkerChoice>::bitSizeOf(const View<::test_object::ppmr_allocator::WalkerChoice>& view, BitSize bitPosition)
{
    BitSize endBitPosition = bitPosition;
    switch (view.zserioChoiceTag())
    {
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value8:
        endBitPosition += detail::bitSizeOf(view.value8(), endBitPosition);
        break;
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value16:
        endBitPosition += detail::bitSizeOf(view.value16(), endBitPosition);
        break;
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value32:
        endBitPosition += detail::bitSizeOf(view.value32(), endBitPosition);
        break;
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value64:
        endBitPosition += detail::bitSizeOf(view.value64(), endBitPosition);
        break;
    default:
        break;
    }

    return endBitPosition - bitPosition;
}

void ObjectTraits<::test_object::ppmr_allocator::WalkerChoice>::write(BitStreamWriter& writer, const View<::test_object::ppmr_allocator::WalkerChoice>& view)
{
    switch (view.zserioChoiceTag())
    {
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value8:
        detail::write(writer, view.value8());
        break;
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value16:
        detail::write(writer, view.value16());
        break;
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value32:
        detail::write(writer, view.value32());
        break;
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value64:
        detail::write(writer, view.value64());
        break;
    default:
        break;
    }
}

View<::test_object::ppmr_allocator::WalkerChoice> ObjectTraits<::test_object::ppmr_allocator::WalkerChoice>::read(BitStreamReader& reader, ::test_object::ppmr_allocator::WalkerChoice& data,
        ::zserio::UInt8 selector_)
{
    View<::test_object::ppmr_allocator::WalkerChoice> view(data,
            selector_);
    switch (view.selector())
    {
    case 8:
        data.emplace<::test_object::ppmr_allocator::WalkerChoice::Tag::value8>();
        detail::read(reader, data.get<::test_object::ppmr_allocator::WalkerChoice::Tag::value8>());
        break;
    case 16:
        data.emplace<::test_object::ppmr_allocator::WalkerChoice::Tag::value16>();
        detail::read(reader, data.get<::test_object::ppmr_allocator::WalkerChoice::Tag::value16>());
        break;
    case 32:
        data.emplace<::test_object::ppmr_allocator::WalkerChoice::Tag::value32>();
        detail::read(reader, data.get<::test_object::ppmr_allocator::WalkerChoice::Tag::value32>());
        break;
    case 64:
        data.emplace<::test_object::ppmr_allocator::WalkerChoice::Tag::value64>();
        detail::read(reader, data.get<::test_object::ppmr_allocator::WalkerChoice::Tag::value64>());
        break;
    default:
        // empty
        break;
    }

    return view;
}

const ::zserio::ppmr::ITypeInfo& TypeInfo<::test_object::ppmr_allocator::WalkerChoice, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>::get()
{
    using AllocatorType = ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>;

    static const ::std::string_view templateName;
    static const ::zserio::Span<::zserio::BasicTemplateArgumentInfo<AllocatorType>> templateArguments;

    static const ::std::array<::zserio::BasicFieldInfo<AllocatorType>, 4> fields = {
        ::zserio::BasicFieldInfo<AllocatorType>{
            "value8", // schemaName
            ::zserio::typeInfo<::zserio::UInt8, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "value16", // schemaName
            ::zserio::typeInfo<::zserio::UInt16, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "value32", // schemaName
            ::zserio::typeInfo<::zserio::UInt32, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "value64", // schemaName
            ::zserio::typeInfo<::zserio::UInt64, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        }
    };

    static const ::std::array<::zserio::BasicParameterInfo<AllocatorType>, 1> parameters = {
        ::zserio::BasicParameterInfo<AllocatorType>{
            "selector",
            ::zserio::typeInfo<::zserio::UInt8, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>()
        }
    };

    static const ::zserio::Span<::zserio::BasicFunctionInfo<AllocatorType>> functions;

    static const std::array<::std::string_view, 1> case0Expressions = {
        "8"
    };
    static const std::array<::std::string_view, 1> case1Expressions = {
        "16"
    };
    static const std::array<::std::string_view, 1> case2Expressions = {
        "32"
    };
    static const std::array<::std::string_view, 1> case3Expressions = {
        "64"
    };
    static const ::std::array<::zserio::BasicCaseInfo<AllocatorType>, 5> cases = {
        ::zserio::BasicCaseInfo<AllocatorType>{
            case0Expressions,
            &fields[0]
        },
        ::zserio::BasicCaseInfo<AllocatorType>{
            case1Expressions,
            &fields[1]
        },
        ::zserio::BasicCaseInfo<AllocatorType>{
            case2Expressions,
            &fields[2]
        },
        ::zserio::BasicCaseInfo<AllocatorType>{
            case3Expressions,
            &fields[3]
        },
        ::zserio::BasicCaseInfo<AllocatorType>{
            {}, nullptr
        }
    };

    static const ::zserio::detail::ChoiceTypeInfo<AllocatorType> typeInfo = {
        "test_object.ppmr_allocator.WalkerChoice",
        [](const AllocatorType& allocator) -> ::zserio::ppmr::IReflectableDataPtr
        {
            return ::std::allocate_shared<::zserio::detail::ReflectableDataOwner<::test_object::ppmr_allocator::WalkerChoice>>(allocator);
        },
        templateName, templateArguments,
        fields, parameters, functions, "selector()", cases
    };

    return typeInfo;
}

::zserio::ppmr::IReflectableDataConstPtr Reflectable<::test_object::ppmr_allocator::WalkerChoice, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>::create(
        const ::test_object::ppmr_allocator::WalkerChoice& value, const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& allocator)
{
    class ReflectableImpl : public ::zserio::detail::ReflectableDataConstAllocatorHolderBase<::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>
    {
    public:
        using Base = ::zserio::detail::ReflectableDataConstAllocatorHolderBase<::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>;
        using Base::getField;
        using Base::getAnyValue;

        explicit ReflectableImpl(const ::test_object::ppmr_allocator::WalkerChoice& object, const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& alloc = {}) :
                ::zserio::detail::ReflectableDataConstAllocatorHolderBase<::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(typeInfo<::test_object::ppmr_allocator::WalkerChoice>(), alloc),
                m_object(object)
        {}

        ::zserio::ppmr::IReflectableDataConstPtr getField(::std::string_view name) const override
        {
            if (name == "value8")
            {
                return ::zserio::reflectable(
                        get<::test_object::ppmr_allocator::WalkerChoice::Tag::value8>(m_object), get_allocator());
            }
            if (name == "value16")
            {
                return ::zserio::reflectable(
                        get<::test_object::ppmr_allocator::WalkerChoice::Tag::value16>(m_object), get_allocator());
            }
            if (name == "value32")
            {
                return ::zserio::reflectable(
                        get<::test_object::ppmr_allocator::WalkerChoice::Tag::value32>(m_object), get_allocator());
            }
            if (name == "value64")
            {
                return ::zserio::reflectable(
                        get<::test_object::ppmr_allocator::WalkerChoice::Tag::value64>(m_object), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'WalkerChoice'!";
        }

        ::std::string_view getChoice() const override
        {
            switch (m_object.index())
            {
            case ::test_object::ppmr_allocator::WalkerChoice::Tag::value8:
                return "value8";
            case ::test_object::ppmr_allocator::WalkerChoice::Tag::value16:
                return "value16";
            case ::test_object::ppmr_allocator::WalkerChoice::Tag::value32:
                return "value32";
            case ::test_object::ppmr_allocator::WalkerChoice::Tag::value64:
                return "value64";
            default:
                return "";
            }
        }

        ::zserio::ppmr::Any getAnyValue(const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& alloc) const override
        {
            return ::zserio::ppmr::Any(::std::cref(m_object), alloc);
        }

    private:
        const ::test_object::ppmr_allocator::WalkerChoice& m_object;
    };

    return ::std::allocate_shared<ReflectableImpl>(allocator, value);
}

::zserio::ppmr::IReflectableDataPtr Reflectable<::test_object::ppmr_allocator::WalkerChoice, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>::create(
        ::test_object::ppmr_allocator::WalkerChoice& value, const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& allocator)
{
    class ReflectableImpl : public ::zserio::detail::ReflectableDataAllocatorHolderBase<::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>
    {
    public:
        using Base = ::zserio::detail::ReflectableDataAllocatorHolderBase<::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>;
        using Base::getField;
        using Base::getAnyValue;

        explicit ReflectableImpl(::test_object::ppmr_allocator::WalkerChoice& object, const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& alloc = {}) :
                ::zserio::detail::ReflectableDataAllocatorHolderBase<::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(typeInfo<::test_object::ppmr_allocator::WalkerChoice>(), alloc),
                m_object(object)
        {}

        ::zserio::ppmr::IReflectableDataConstPtr getField(::std::string_view name) const override
        {
            if (name == "value8")
            {
                return ::zserio::reflectable(
                        get<::test_object::ppmr_allocator::WalkerChoice::Tag::value8>(m_object), get_allocator());
            }
            if (name == "value16")
            {
                return ::zserio::reflectable(
                        get<::test_object::ppmr_allocator::WalkerChoice::Tag::value16>(m_object), get_allocator());
            }
            if (name == "value32")
            {
                return ::zserio::reflectable(
                        get<::test_object::ppmr_allocator::WalkerChoice::Tag::value32>(m_object), get_allocator());
            }
            if (name == "value64")
            {
                return ::zserio::reflectable(
                        get<::test_object::ppmr_allocator::WalkerChoice::Tag::value64>(m_object), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'WalkerChoice'!";
        }

        ::zserio::ppmr::IReflectableDataPtr getField(::std::string_view name) override
        {
            if (name == "value8")
            {
                return ::zserio::reflectable(
                        get<::test_object::ppmr_allocator::WalkerChoice::Tag::value8>(m_object), get_allocator());
            }
            if (name == "value16")
            {
                return ::zserio::reflectable(
                        get<::test_object::ppmr_allocator::WalkerChoice::Tag::value16>(m_object), get_allocator());
            }
            if (name == "value32")
            {
                return ::zserio::reflectable(
                        get<::test_object::ppmr_allocator::WalkerChoice::Tag::value32>(m_object), get_allocator());
            }
            if (name == "value64")
            {
                return ::zserio::reflectable(
                        get<::test_object::ppmr_allocator::WalkerChoice::Tag::value64>(m_object), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'WalkerChoice'!";
        }

        void setField(::std::string_view name, const ::zserio::ppmr::Any& value) override
        {
            if (name == "value8")
            {
                m_object.template emplace<::test_object::ppmr_allocator::WalkerChoice::Tag::value8>(
                        ::zserio::ReflectableUtil::fromAny<::zserio::UInt8>(value));
                return;
            }
            if (name == "value16")
            {
                m_object.template emplace<::test_object::ppmr_allocator::WalkerChoice::Tag::value16>(
                        ::zserio::ReflectableUtil::fromAny<::zserio::UInt16>(value));
                return;
            }
            if (name == "value32")
            {
                m_object.template emplace<::test_object::ppmr_allocator::WalkerChoice::Tag::value32>(
                        ::zserio::ReflectableUtil::fromAny<::zserio::UInt32>(value));
                return;
            }
            if (name == "value64")
            {
                m_object.template emplace<::test_object::ppmr_allocator::WalkerChoice::Tag::value64>(
                        ::zserio::ReflectableUtil::fromAny<::zserio::UInt64>(value));
                return;
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'WalkerChoice'!";
        }

        ::zserio::ppmr::IReflectableDataPtr createField(::std::string_view name) override
        {
            if (name == "value8")
            {
                m_object.template emplace<::test_object::ppmr_allocator::WalkerChoice::Tag::value8>();
                return ::zserio::reflectable(get<::test_object::ppmr_allocator::WalkerChoice::Tag::value8>(m_object), get_allocator());
            }
            if (name == "value16")
            {
                m_object.template emplace<::test_object::ppmr_allocator::WalkerChoice::Tag::value16>();
                return ::zserio::reflectable(get<::test_object::ppmr_allocator::WalkerChoice::Tag::value16>(m_object), get_allocator());
            }
            if (name == "value32")
            {
                m_object.template emplace<::test_object::ppmr_allocator::WalkerChoice::Tag::value32>();
                return ::zserio::reflectable(get<::test_object::ppmr_allocator::WalkerChoice::Tag::value32>(m_object), get_allocator());
            }
            if (name == "value64")
            {
                m_object.template emplace<::test_object::ppmr_allocator::WalkerChoice::Tag::value64>();
                return ::zserio::reflectable(get<::test_object::ppmr_allocator::WalkerChoice::Tag::value64>(m_object), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'WalkerChoice'!";
        }

        ::std::string_view getChoice() const override
        {
            switch (m_object.index())
            {
            case ::test_object::ppmr_allocator::WalkerChoice::Tag::value8:
                return "value8";
            case ::test_object::ppmr_allocator::WalkerChoice::Tag::value16:
                return "value16";
            case ::test_object::ppmr_allocator::WalkerChoice::Tag::value32:
                return "value32";
            case ::test_object::ppmr_allocator::WalkerChoice::Tag::value64:
                return "value64";
            default:
                return "";
            }
        }

        ::zserio::ppmr::Any getAnyValue(const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& alloc) const override
        {
            return ::zserio::ppmr::Any(::std::cref(m_object), alloc);
        }

        ::zserio::ppmr::Any getAnyValue(const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& alloc) override
        {
            return ::zserio::ppmr::Any(::std::ref(m_object), alloc);
        }

    private:
        ::test_object::ppmr_allocator::WalkerChoice& m_object;
    };

    return ::std::allocate_shared<ReflectableImpl>(allocator, value);
}

::zserio::ppmr::IIntrospectableViewConstPtr Introspectable<::test_object::ppmr_allocator::WalkerChoice, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>::create(
        const View<::test_object::ppmr_allocator::WalkerChoice>& view, const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& allocator)
{
    class IntrospectableImpl : public ::zserio::detail::CompoundIntrospectableViewBase<::test_object::ppmr_allocator::WalkerChoice, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>
    {
    public:
        explicit IntrospectableImpl(const ::zserio::View<::test_object::ppmr_allocator::WalkerChoice>& view_, const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& alloc = {}) :
                ::zserio::detail::CompoundIntrospectableViewBase<::test_object::ppmr_allocator::WalkerChoice, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(
                        view_, alloc)
        {}

        ::zserio::ppmr::IIntrospectableViewConstPtr getField(::std::string_view name) const override
        {
            if (name == "value8")
            {
                return ::zserio::introspectable(getValue().value8(), get_allocator());
            }
            if (name == "value16")
            {
                return ::zserio::introspectable(getValue().value16(), get_allocator());
            }
            if (name == "value32")
            {
                return ::zserio::introspectable(getValue().value32(), get_allocator());
            }
            if (name == "value64")
            {
                return ::zserio::introspectable(getValue().value64(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'WalkerChoice'!";
        }

        ::zserio::ppmr::IIntrospectableViewConstPtr getParameter(::std::string_view name) const override
        {
            if (name == "selector")
            {
                return ::zserio::introspectable(getValue().selector(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Parameter '") << name << "' doesn't exist in 'WalkerChoice'!";
        }

        ::std::string_view getChoice() const override
        {
            switch (getValue().zserioChoiceTag())
            {
            case ::test_object::ppmr_allocator::WalkerChoice::Tag::value8:
                return "value8";
            case ::test_object::ppmr_allocator::WalkerChoice::Tag::value16:
                return "value16";
            case ::test_object::ppmr_allocator::WalkerChoice::Tag::value32:
                return "value32";
            case ::test_object::ppmr_allocator::WalkerChoice::Tag::value64:
                return "value64";
            default:
                return "";
            }
        }
    };

    return ::std::allocate_shared<IntrospectableImpl>(allocator, view);
}

} // namespace detail
} // namespace zserio

namespace std
{

size_t hash<::test_object::ppmr_allocator::WalkerChoice>::operator()(const ::test_object::ppmr_allocator::WalkerChoice& value) const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, static_cast<const ::test_object::ppmr_allocator::WalkerChoice::Base&>(value));
    return static_cast<size_t>(result);
}

size_t hash<::zserio::View<::test_object::ppmr_allocator::WalkerChoice>>::operator()(const ::zserio::View<::test_object::ppmr_allocator::WalkerChoice>& view) const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, view.selector());
    switch (view.zserioChoiceTag())
    {
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value8:
        result = ::zserio::calcHashCode(result, view.value8());
        break;
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value16:
        result = ::zserio::calcHashCode(result, view.value16());
        break;
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value32:
        result = ::zserio::calcHashCode(result, view.value32());
        break;
    case ::test_object::ppmr_allocator::WalkerChoice::Tag::value64:
        result = ::zserio::calcHashCode(result, view.value64());
        break;
    default:
        break;
    }

    return static_cast<size_t>(result);
}

} // namespace std
