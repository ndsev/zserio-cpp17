/**
 * Automatically generated by Zserio C++17 generator version 0.4.0 using Zserio core 2.16.0.
 * Generator setup: typeInfoCode, ppmrAllocator.
 */

#include <zserio/BitPositionUtil.h>
#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/IntrospectableView.h>
#include <zserio/ReflectableData.h>
#include <zserio/ReflectableUtil.h>
#include <zserio/TypeInfo.h>

#include <test_object/ppmr_allocator/CreatorObject.h>

namespace test_object
{
namespace ppmr_allocator
{

CreatorObject::CreatorObject() noexcept :
        CreatorObject(allocator_type{})
{}

CreatorObject::CreatorObject(const allocator_type& allocator) noexcept :
        value(),
        nested(allocator),
        text(allocator),
        nestedArray(allocator),
        textArray(allocator),
        externArray(allocator),
        bytesArray(allocator),
        optionalBool(allocator),
        optionalNested(allocator)
{}

CreatorObject::CreatorObject(CreatorObject&& other, const allocator_type& allocator) :
        value(other.value),
        nested(std::move(other.nested), allocator),
        text(std::move(other.text), allocator),
        nestedArray(std::move(other.nestedArray), allocator),
        textArray(std::move(other.textArray), allocator),
        externArray(std::move(other.externArray), allocator),
        bytesArray(std::move(other.bytesArray), allocator),
        optionalBool(std::move(other.optionalBool), allocator),
        optionalNested(std::move(other.optionalNested), allocator)
{}

CreatorObject::CreatorObject(const CreatorObject& other, const allocator_type& allocator) :
        value(other.value),
        nested(other.nested, allocator),
        text(other.text, allocator),
        nestedArray(other.nestedArray, allocator),
        textArray(other.textArray, allocator),
        externArray(other.externArray, allocator),
        bytesArray(other.bytesArray, allocator),
        optionalBool(other.optionalBool, allocator),
        optionalNested(other.optionalNested, allocator)
{}

CreatorObject::CreatorObject(
        ::zserio::UInt32 value_,
        ::test_object::ppmr_allocator::CreatorNested nested_,
        ::zserio::ppmr::String text_,
        ::zserio::ppmr::Vector<::test_object::ppmr_allocator::CreatorNested> nestedArray_,
        ::zserio::ppmr::Vector<::zserio::ppmr::String> textArray_,
        ::zserio::ppmr::Optional<::zserio::ppmr::Vector<::zserio::ppmr::BitBuffer>> externArray_,
        ::zserio::ppmr::Optional<::zserio::ppmr::Vector<::zserio::ppmr::Bytes>> bytesArray_,
        ::zserio::ppmr::Optional<::zserio::Bool> optionalBool_,
        ::zserio::ppmr::Optional<::test_object::ppmr_allocator::CreatorNested> optionalNested_,
        const allocator_type& allocator) :
        value(value_),
        nested(::std::move(nested_), allocator),
        text(::std::move(text_), allocator),
        nestedArray(::std::move(nestedArray_), allocator),
        textArray(::std::move(textArray_), allocator),
        externArray(::std::move(externArray_), allocator),
        bytesArray(::std::move(bytesArray_), allocator),
        optionalBool(::std::move(optionalBool_), allocator),
        optionalNested(::std::move(optionalNested_), allocator)
{}

bool operator==(const ::test_object::ppmr_allocator::CreatorObject& lhs, const ::test_object::ppmr_allocator::CreatorObject& rhs)
{
    return ::std::tie(
            lhs.value,
            lhs.nested,
            lhs.text,
            lhs.nestedArray,
            lhs.textArray,
            lhs.externArray,
            lhs.bytesArray,
            lhs.optionalBool,
            lhs.optionalNested)
            == ::std::tie(
            rhs.value,
            rhs.nested,
            rhs.text,
            rhs.nestedArray,
            rhs.textArray,
            rhs.externArray,
            rhs.bytesArray,
            rhs.optionalBool,
            rhs.optionalNested);
}

bool operator<(const ::test_object::ppmr_allocator::CreatorObject& lhs, const ::test_object::ppmr_allocator::CreatorObject& rhs)
{
    return ::std::tie(
            lhs.value,
            lhs.nested,
            lhs.text,
            lhs.nestedArray,
            lhs.textArray,
            lhs.externArray,
            lhs.bytesArray,
            lhs.optionalBool,
            lhs.optionalNested)
            < ::std::tie(
            rhs.value,
            rhs.nested,
            rhs.text,
            rhs.nestedArray,
            rhs.textArray,
            rhs.externArray,
            rhs.bytesArray,
            rhs.optionalBool,
            rhs.optionalNested);
}

bool operator!=(const ::test_object::ppmr_allocator::CreatorObject& lhs, const ::test_object::ppmr_allocator::CreatorObject& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const ::test_object::ppmr_allocator::CreatorObject& lhs, const ::test_object::ppmr_allocator::CreatorObject& rhs)
{
    return rhs < lhs;
}

bool operator<=(const ::test_object::ppmr_allocator::CreatorObject& lhs, const ::test_object::ppmr_allocator::CreatorObject& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const ::test_object::ppmr_allocator::CreatorObject& lhs, const ::test_object::ppmr_allocator::CreatorObject& rhs)
{
    return !(lhs < rhs);
}

} // namespace ppmr_allocator
} // namespace test_object

namespace zserio
{

View<::test_object::ppmr_allocator::CreatorNested> View<::test_object::ppmr_allocator::CreatorObject>::ZserioNestedArrayArrayTraits::at(const OwnerType& owner,
        const ::test_object::ppmr_allocator::CreatorNested& element, size_t)
{
    return View<::test_object::ppmr_allocator::CreatorNested>(element, detail::makeParameter<0, ::test_object::ppmr_allocator::CreatorNested>(owner.value()));
}

void View<::test_object::ppmr_allocator::CreatorObject>::ZserioNestedArrayArrayTraits::read(BitStreamReader& reader, const OwnerType& owner,
        ::test_object::ppmr_allocator::CreatorNested& element, size_t)
{
    (void)detail::read(reader, element, detail::makeParameter<0, ::test_object::ppmr_allocator::CreatorNested>(owner.value()));
}

View<::test_object::ppmr_allocator::CreatorObject>::View(const ::test_object::ppmr_allocator::CreatorObject& data) noexcept :
        m_data(&data)
{}

View<::test_object::ppmr_allocator::CreatorObject>::View(const ::test_object::ppmr_allocator::CreatorObject& data,
        const View&) noexcept :
        m_data(&data)
{}

::zserio::UInt32 View<::test_object::ppmr_allocator::CreatorObject>::value() const
{
    return m_data->value;
}

View<::test_object::ppmr_allocator::CreatorNested> View<::test_object::ppmr_allocator::CreatorObject>::nested() const
{
    return View<::test_object::ppmr_allocator::CreatorNested>{m_data->nested, detail::makeParameter<0, ::test_object::ppmr_allocator::CreatorNested>(value())};
}

::std::string_view View<::test_object::ppmr_allocator::CreatorObject>::text() const
{
    return ::std::string_view{m_data->text};
}

ArrayView<const ::test_object::ppmr_allocator::CreatorNested, View<::test_object::ppmr_allocator::CreatorObject>::ZserioNestedArrayArrayTraits> View<::test_object::ppmr_allocator::CreatorObject>::nestedArray() const
{
    return ArrayView<const ::test_object::ppmr_allocator::CreatorNested, ZserioNestedArrayArrayTraits>{m_data->nestedArray, *this};
}

ArrayView<const ::zserio::ppmr::String> View<::test_object::ppmr_allocator::CreatorObject>::textArray() const
{
    return ArrayView<const ::zserio::ppmr::String>{m_data->textArray};
}

::zserio::ppmr::Optional<ArrayView<const ::zserio::ppmr::BitBuffer>> View<::test_object::ppmr_allocator::CreatorObject>::externArray() const
{
    if (m_data->externArray.has_value())
    {
        return ::zserio::ppmr::Optional<ArrayView<const ::zserio::ppmr::BitBuffer>>{::std::in_place, m_data->externArray.get_allocator(), *m_data->externArray};
    }
    else
    {
        return ::zserio::ppmr::Optional<ArrayView<const ::zserio::ppmr::BitBuffer>>(::std::nullopt, m_data->externArray.get_allocator());
    }
}

::zserio::ppmr::Optional<ArrayView<const ::zserio::ppmr::Bytes>> View<::test_object::ppmr_allocator::CreatorObject>::bytesArray() const
{
    if (m_data->bytesArray.has_value())
    {
        return ::zserio::ppmr::Optional<ArrayView<const ::zserio::ppmr::Bytes>>{::std::in_place, m_data->bytesArray.get_allocator(), *m_data->bytesArray};
    }
    else
    {
        return ::zserio::ppmr::Optional<ArrayView<const ::zserio::ppmr::Bytes>>(::std::nullopt, m_data->bytesArray.get_allocator());
    }
}

::zserio::ppmr::Optional<::zserio::Bool> View<::test_object::ppmr_allocator::CreatorObject>::optionalBool() const
{
    return m_data->optionalBool;
}

::zserio::ppmr::Optional<View<::test_object::ppmr_allocator::CreatorNested>> View<::test_object::ppmr_allocator::CreatorObject>::optionalNested() const
{
    if (m_data->optionalNested.has_value())
    {
        return ::zserio::ppmr::Optional<View<::test_object::ppmr_allocator::CreatorNested>>{::std::in_place, m_data->optionalNested.get_allocator(), *m_data->optionalNested, detail::makeParameter<0, ::test_object::ppmr_allocator::CreatorNested>(value())};
    }
    else
    {
        return ::zserio::ppmr::Optional<View<::test_object::ppmr_allocator::CreatorNested>>(::std::nullopt, m_data->optionalNested.get_allocator());
    }
}

const ::test_object::ppmr_allocator::CreatorObject& View<::test_object::ppmr_allocator::CreatorObject>::zserioData() const
{
    return *m_data;
}

bool operator==(const View<::test_object::ppmr_allocator::CreatorObject>& lhs, const View<::test_object::ppmr_allocator::CreatorObject>& rhs)
{
    return lhs.value() == rhs.value() &&
            lhs.nested() == rhs.nested() &&
            lhs.text() == rhs.text() &&
            lhs.nestedArray() == rhs.nestedArray() &&
            lhs.textArray() == rhs.textArray() &&
            lhs.externArray() == rhs.externArray() &&
            lhs.bytesArray() == rhs.bytesArray() &&
            lhs.optionalBool() == rhs.optionalBool() &&
            lhs.optionalNested() == rhs.optionalNested();
}

bool operator<(const View<::test_object::ppmr_allocator::CreatorObject>& lhs, const View<::test_object::ppmr_allocator::CreatorObject>& rhs)
{
    if (lhs.value() != rhs.value())
    {
        return lhs.value() < rhs.value();
    }
    if (lhs.nested() != rhs.nested())
    {
        return lhs.nested() < rhs.nested();
    }
    if (lhs.text() != rhs.text())
    {
        return lhs.text() < rhs.text();
    }
    if (lhs.nestedArray() != rhs.nestedArray())
    {
        return lhs.nestedArray() < rhs.nestedArray();
    }
    if (lhs.textArray() != rhs.textArray())
    {
        return lhs.textArray() < rhs.textArray();
    }
    if (lhs.externArray() != rhs.externArray())
    {
        return lhs.externArray() < rhs.externArray();
    }
    if (lhs.bytesArray() != rhs.bytesArray())
    {
        return lhs.bytesArray() < rhs.bytesArray();
    }
    if (lhs.optionalBool() != rhs.optionalBool())
    {
        return lhs.optionalBool() < rhs.optionalBool();
    }
    if (lhs.optionalNested() != rhs.optionalNested())
    {
        return lhs.optionalNested() < rhs.optionalNested();
    }

    return false;
}

bool operator!=(const View<::test_object::ppmr_allocator::CreatorObject>& lhs, const View<::test_object::ppmr_allocator::CreatorObject>& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const View<::test_object::ppmr_allocator::CreatorObject>& lhs, const View<::test_object::ppmr_allocator::CreatorObject>& rhs)
{
    return rhs < lhs;
}

bool operator<=(const View<::test_object::ppmr_allocator::CreatorObject>& lhs, const View<::test_object::ppmr_allocator::CreatorObject>& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const View<::test_object::ppmr_allocator::CreatorObject>& lhs, const View<::test_object::ppmr_allocator::CreatorObject>& rhs)
{
    return !(lhs < rhs);
}

namespace detail
{

void ObjectTraits<::test_object::ppmr_allocator::CreatorObject>::validate(const View<::test_object::ppmr_allocator::CreatorObject>& view, ::std::string_view)
{
    detail::validate(view.value(), "'CreatorObject.value'");
    detail::validate(view.nested(), "'CreatorObject.nested'");
    detail::validate(view.text(), "'CreatorObject.text'");
    detail::validate<ArrayType::AUTO>(view.nestedArray(), "'CreatorObject.nestedArray'");
    detail::validate<ArrayType::AUTO>(view.textArray(), "'CreatorObject.textArray'");
    if (view.externArray().has_value())
    {
        detail::validate<ArrayType::AUTO>(*view.externArray(), "'CreatorObject.externArray'");
    }
    if (view.bytesArray().has_value())
    {
        detail::validate<ArrayType::AUTO>(*view.bytesArray(), "'CreatorObject.bytesArray'");
    }
    if (view.optionalBool().has_value())
    {
        detail::validate(*view.optionalBool(), "'CreatorObject.optionalBool'");
    }
    if (view.optionalNested().has_value())
    {
        detail::validate(*view.optionalNested(), "'CreatorObject.optionalNested'");
    }
}

BitSize ObjectTraits<::test_object::ppmr_allocator::CreatorObject>::bitSizeOf(const View<::test_object::ppmr_allocator::CreatorObject>& view, BitSize bitPosition)
{
    BitSize endBitPosition = bitPosition;

    auto value_ = view.value();
    endBitPosition += detail::bitSizeOf(value_, endBitPosition);
    auto nested_ = view.nested();
    endBitPosition += detail::bitSizeOf(nested_, endBitPosition);
    auto text_ = view.text();
    endBitPosition += detail::bitSizeOf(text_, endBitPosition);
    auto nestedArray_ = view.nestedArray();
    endBitPosition += detail::bitSizeOf<ArrayType::AUTO>(nestedArray_, endBitPosition);
    auto textArray_ = view.textArray();
    endBitPosition += detail::bitSizeOf<ArrayType::AUTO>(textArray_, endBitPosition);
    auto externArray_ = view.externArray();
    endBitPosition += detail::bitSizeOf(Bool());
    if (externArray_.has_value())
    {
        endBitPosition += detail::bitSizeOf<ArrayType::AUTO>(*externArray_, endBitPosition);
    }
    auto bytesArray_ = view.bytesArray();
    endBitPosition += detail::bitSizeOf(Bool());
    if (bytesArray_.has_value())
    {
        endBitPosition += detail::bitSizeOf<ArrayType::AUTO>(*bytesArray_, endBitPosition);
    }
    auto optionalBool_ = view.optionalBool();
    endBitPosition += detail::bitSizeOf(Bool());
    if (optionalBool_.has_value())
    {
        endBitPosition += detail::bitSizeOf(*optionalBool_, endBitPosition);
    }
    auto optionalNested_ = view.optionalNested();
    endBitPosition += detail::bitSizeOf(Bool());
    if (optionalNested_.has_value())
    {
        endBitPosition += detail::bitSizeOf(*optionalNested_, endBitPosition);
    }

    return endBitPosition - bitPosition;
}

void ObjectTraits<::test_object::ppmr_allocator::CreatorObject>::write(BitStreamWriter& writer, const View<::test_object::ppmr_allocator::CreatorObject>& view)
{
    auto value_ = view.value();
    detail::write(writer, value_);
    auto nested_ = view.nested();
    detail::write(writer, nested_);
    auto text_ = view.text();
    detail::write(writer, text_);
    auto nestedArray_ = view.nestedArray();
    detail::write<ArrayType::AUTO>(writer, nestedArray_);
    auto textArray_ = view.textArray();
    detail::write<ArrayType::AUTO>(writer, textArray_);
    auto externArray_ = view.externArray();
    if (externArray_.has_value())
    {
        writer.writeBool(true);
        detail::write<ArrayType::AUTO>(writer, *externArray_);
    }
    else
    {
        writer.writeBool(false);
    }
    auto bytesArray_ = view.bytesArray();
    if (bytesArray_.has_value())
    {
        writer.writeBool(true);
        detail::write<ArrayType::AUTO>(writer, *bytesArray_);
    }
    else
    {
        writer.writeBool(false);
    }
    auto optionalBool_ = view.optionalBool();
    if (optionalBool_.has_value())
    {
        writer.writeBool(true);
        detail::write(writer, *optionalBool_);
    }
    else
    {
        writer.writeBool(false);
    }
    auto optionalNested_ = view.optionalNested();
    if (optionalNested_.has_value())
    {
        writer.writeBool(true);
        detail::write(writer, *optionalNested_);
    }
    else
    {
        writer.writeBool(false);
    }
}

View<::test_object::ppmr_allocator::CreatorObject> ObjectTraits<::test_object::ppmr_allocator::CreatorObject>::read(BitStreamReader& reader, ::test_object::ppmr_allocator::CreatorObject& data)
{
    View<::test_object::ppmr_allocator::CreatorObject> view(data);
    detail::read(reader, data.value);
    (void)detail::read(reader, data.nested, detail::makeParameter<0, ::test_object::ppmr_allocator::CreatorNested>(view.value()));
    detail::read(reader, data.text);
    (void)detail::readWithTraits<ArrayType::AUTO, View<::test_object::ppmr_allocator::CreatorObject>::ZserioNestedArrayArrayTraits>(reader, data.nestedArray, view);
    detail::read<ArrayType::AUTO>(reader, data.textArray);
    if (reader.readBool())
    {
        data.externArray.emplace();
        detail::read<ArrayType::AUTO>(reader, *data.externArray);
    }
    if (reader.readBool())
    {
        data.bytesArray.emplace();
        detail::read<ArrayType::AUTO>(reader, *data.bytesArray);
    }
    if (reader.readBool())
    {
        data.optionalBool.emplace();
        detail::read(reader, *data.optionalBool);
    }
    if (reader.readBool())
    {
        data.optionalNested.emplace();
        (void)detail::read(reader, *data.optionalNested, detail::makeParameter<0, ::test_object::ppmr_allocator::CreatorNested>(view.value()));
    }
    return view;
}

const ::zserio::ppmr::ITypeInfo& TypeInfo<::test_object::ppmr_allocator::CreatorObject, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>::get()
{
    using AllocatorType = ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>;

    static const ::std::string_view templateName;
    static const ::zserio::Span<::zserio::BasicTemplateArgumentInfo<AllocatorType>> templateArguments;

    static const ::std::array<::std::string_view, 1> nestedTypeArguments = {
        "value()"
    };
    static const ::std::array<::std::string_view, 1> nestedArrayTypeArguments = {
        "value()"
    };
    static const ::std::array<::std::string_view, 1> optionalNestedTypeArguments = {
        "value()"
    };
    static const ::std::array<::zserio::BasicFieldInfo<AllocatorType>, 9> fields = {
        ::zserio::BasicFieldInfo<AllocatorType>{
            "value", // schemaName
            ::zserio::typeInfo<::zserio::UInt32, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "nested", // schemaName
            ::zserio::typeInfo<::test_object::ppmr_allocator::CreatorNested, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            nestedTypeArguments, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "text", // schemaName
            ::zserio::typeInfo<::zserio::ppmr::String, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "nestedArray", // schemaName
            ::zserio::typeInfo<::test_object::ppmr_allocator::CreatorNested, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            nestedArrayTypeArguments, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "textArray", // schemaName
            ::zserio::typeInfo<::zserio::ppmr::String, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "externArray", // schemaName
            ::zserio::typeInfo<::zserio::ppmr::BitBuffer, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            true, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "bytesArray", // schemaName
            ::zserio::typeInfo<::zserio::ppmr::Bytes, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            true, // isOptional
            {}, // optionalClause
            {}, // constraint
            true, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "optionalBool", // schemaName
            ::zserio::typeInfo<::zserio::Bool, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            true, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "optionalNested", // schemaName
            ::zserio::typeInfo<::test_object::ppmr_allocator::CreatorNested, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            optionalNestedTypeArguments, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            true, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        }
    };

    static const ::zserio::Span<::zserio::BasicParameterInfo<AllocatorType>> parameters;

    static const ::zserio::Span<::zserio::BasicFunctionInfo<AllocatorType>> functions;

    static const ::zserio::detail::StructTypeInfo<AllocatorType> typeInfo = {
        "test_object.ppmr_allocator.CreatorObject",
        [](const AllocatorType& allocator) -> ::zserio::ppmr::IReflectableDataPtr
        {
            return ::std::allocate_shared<::zserio::detail::ReflectableDataOwner<::test_object::ppmr_allocator::CreatorObject>>(allocator);
        },
        templateName, templateArguments, fields, parameters, functions
    };

    return typeInfo;
}

::zserio::ppmr::IReflectableDataConstPtr Reflectable<::test_object::ppmr_allocator::CreatorObject, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>::create(
        const ::test_object::ppmr_allocator::CreatorObject& value, const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& allocator)
{
    class ReflectableImpl : public ::zserio::detail::ReflectableDataConstAllocatorHolderBase<::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>
    {
    public:
        using Base = ::zserio::detail::ReflectableDataConstAllocatorHolderBase<::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>;
        using Base::getField;
        using Base::getAnyValue;

        explicit ReflectableImpl(const ::test_object::ppmr_allocator::CreatorObject& object, const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& alloc = {}) :
                ::zserio::detail::ReflectableDataConstAllocatorHolderBase<::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(typeInfo<::test_object::ppmr_allocator::CreatorObject>(), alloc),
                m_object(object)
        {}

        ::zserio::ppmr::IReflectableDataConstPtr getField(::std::string_view name) const override
        {
            if (name == "value")
            {
                return ::zserio::reflectable(m_object.value, get_allocator());
            }
            if (name == "nested")
            {
                return ::zserio::reflectable(m_object.nested, get_allocator());
            }
            if (name == "text")
            {
                return ::zserio::reflectable(m_object.text, get_allocator());
            }
            if (name == "nestedArray")
            {
                return ::zserio::reflectableArray(m_object.nestedArray, get_allocator());
            }
            if (name == "textArray")
            {
                return ::zserio::reflectableArray(m_object.textArray, get_allocator());
            }
            if (name == "externArray")
            {
                if (!m_object.externArray.has_value())
                {
                    return nullptr;
                }

                return ::zserio::reflectableArray(*m_object.externArray, get_allocator());
            }
            if (name == "bytesArray")
            {
                if (!m_object.bytesArray.has_value())
                {
                    return nullptr;
                }

                return ::zserio::reflectableArray(*m_object.bytesArray, get_allocator());
            }
            if (name == "optionalBool")
            {
                if (!m_object.optionalBool.has_value())
                {
                    return nullptr;
                }

                return ::zserio::reflectable(*m_object.optionalBool, get_allocator());
            }
            if (name == "optionalNested")
            {
                if (!m_object.optionalNested.has_value())
                {
                    return nullptr;
                }

                return ::zserio::reflectable(*m_object.optionalNested, get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'CreatorObject'!";
        }

        ::zserio::ppmr::Any getAnyValue(const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& alloc) const override
        {
            return ::zserio::ppmr::Any(::std::cref(m_object), alloc);
        }

    private:
        const ::test_object::ppmr_allocator::CreatorObject& m_object;
    };

    return ::std::allocate_shared<ReflectableImpl>(allocator, value);
}

::zserio::ppmr::IReflectableDataPtr Reflectable<::test_object::ppmr_allocator::CreatorObject, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>::create(
        ::test_object::ppmr_allocator::CreatorObject& value, const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& allocator)
{
    class ReflectableImpl : public ::zserio::detail::ReflectableDataAllocatorHolderBase<::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>
    {
    public:
        using Base = ::zserio::detail::ReflectableDataAllocatorHolderBase<::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>;
        using Base::getField;
        using Base::getAnyValue;

        explicit ReflectableImpl(::test_object::ppmr_allocator::CreatorObject& object, const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& alloc = {}) :
                ::zserio::detail::ReflectableDataAllocatorHolderBase<::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(typeInfo<::test_object::ppmr_allocator::CreatorObject>(), alloc),
                m_object(object)
        {}

        ::zserio::ppmr::IReflectableDataConstPtr getField(::std::string_view name) const override
        {
            if (name == "value")
            {
                return ::zserio::reflectable(m_object.value, get_allocator());
            }
            if (name == "nested")
            {
                return ::zserio::reflectable(m_object.nested, get_allocator());
            }
            if (name == "text")
            {
                return ::zserio::reflectable(m_object.text, get_allocator());
            }
            if (name == "nestedArray")
            {
                return ::zserio::reflectableArray(m_object.nestedArray, get_allocator());
            }
            if (name == "textArray")
            {
                return ::zserio::reflectableArray(m_object.textArray, get_allocator());
            }
            if (name == "externArray")
            {
                if (!m_object.externArray.has_value())
                {
                    return nullptr;
                }

                return ::zserio::reflectableArray(*m_object.externArray, get_allocator());
            }
            if (name == "bytesArray")
            {
                if (!m_object.bytesArray.has_value())
                {
                    return nullptr;
                }

                return ::zserio::reflectableArray(*m_object.bytesArray, get_allocator());
            }
            if (name == "optionalBool")
            {
                if (!m_object.optionalBool.has_value())
                {
                    return nullptr;
                }

                return ::zserio::reflectable(*m_object.optionalBool, get_allocator());
            }
            if (name == "optionalNested")
            {
                if (!m_object.optionalNested.has_value())
                {
                    return nullptr;
                }

                return ::zserio::reflectable(*m_object.optionalNested, get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'CreatorObject'!";
        }

        ::zserio::ppmr::IReflectableDataPtr getField(::std::string_view name) override
        {
            if (name == "value")
            {
                return ::zserio::reflectable(m_object.value, get_allocator());
            }
            if (name == "nested")
            {
                return ::zserio::reflectable(m_object.nested, get_allocator());
            }
            if (name == "text")
            {
                return ::zserio::reflectable(m_object.text, get_allocator());
            }
            if (name == "nestedArray")
            {
                return ::zserio::reflectableArray(m_object.nestedArray, get_allocator());
            }
            if (name == "textArray")
            {
                return ::zserio::reflectableArray(m_object.textArray, get_allocator());
            }
            if (name == "externArray")
            {
                if (!m_object.externArray.has_value())
                {
                    return nullptr;
                }

                return ::zserio::reflectableArray(*m_object.externArray, get_allocator());
            }
            if (name == "bytesArray")
            {
                if (!m_object.bytesArray.has_value())
                {
                    return nullptr;
                }

                return ::zserio::reflectableArray(*m_object.bytesArray, get_allocator());
            }
            if (name == "optionalBool")
            {
                if (!m_object.optionalBool.has_value())
                {
                    return nullptr;
                }

                return ::zserio::reflectable(*m_object.optionalBool, get_allocator());
            }
            if (name == "optionalNested")
            {
                if (!m_object.optionalNested.has_value())
                {
                    return nullptr;
                }

                return ::zserio::reflectable(*m_object.optionalNested, get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'CreatorObject'!";
        }

        void setField(::std::string_view name, const ::zserio::ppmr::Any& value) override
        {
            if (name == "value")
            {
                m_object.value = ::zserio::ReflectableUtil::fromAny<::zserio::UInt32>(value);
                return;
            }
            if (name == "nested")
            {
                m_object.nested = ::zserio::ReflectableUtil::fromAny<::test_object::ppmr_allocator::CreatorNested>(value);
                return;
            }
            if (name == "text")
            {
                m_object.text = ::zserio::ReflectableUtil::fromAny<::zserio::ppmr::String>(value);
                return;
            }
            if (name == "nestedArray")
            {
                m_object.nestedArray = ::zserio::ReflectableUtil::fromAny<::zserio::ppmr::Vector<::test_object::ppmr_allocator::CreatorNested>>(value);
                return;
            }
            if (name == "textArray")
            {
                m_object.textArray = ::zserio::ReflectableUtil::fromAny<::zserio::ppmr::Vector<::zserio::ppmr::String>>(value);
                return;
            }
            if (name == "externArray")
            {
                if (value.isType<::std::nullptr_t>())
                {
                    m_object.externArray.reset();
                    return;
                }

                m_object.externArray = ::zserio::ReflectableUtil::fromAny<::zserio::ppmr::Vector<::zserio::ppmr::BitBuffer>>(value);
                return;
            }
            if (name == "bytesArray")
            {
                if (value.isType<::std::nullptr_t>())
                {
                    m_object.bytesArray.reset();
                    return;
                }

                m_object.bytesArray = ::zserio::ReflectableUtil::fromAny<::zserio::ppmr::Vector<::zserio::ppmr::Bytes>>(value);
                return;
            }
            if (name == "optionalBool")
            {
                if (value.isType<::std::nullptr_t>())
                {
                    m_object.optionalBool.reset();
                    return;
                }

                m_object.optionalBool = ::zserio::ReflectableUtil::fromAny<::zserio::Bool>(value);
                return;
            }
            if (name == "optionalNested")
            {
                if (value.isType<::std::nullptr_t>())
                {
                    m_object.optionalNested.reset();
                    return;
                }

                m_object.optionalNested = ::zserio::ReflectableUtil::fromAny<::test_object::ppmr_allocator::CreatorNested>(value);
                return;
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'CreatorObject'!";
        }

        ::zserio::ppmr::IReflectableDataPtr createField(::std::string_view name) override
        {
            if (name == "value")
            {
                m_object.value = ::zserio::UInt32();
                return ::zserio::reflectable(m_object.value, get_allocator());
            }
            if (name == "nested")
            {
                m_object.nested = ::test_object::ppmr_allocator::CreatorNested(get_allocator());
                return ::zserio::reflectable(m_object.nested, get_allocator());
            }
            if (name == "text")
            {
                m_object.text = ::zserio::ppmr::String(get_allocator());
                return ::zserio::reflectable(m_object.text, get_allocator());
            }
            if (name == "nestedArray")
            {
                m_object.nestedArray = ::zserio::ppmr::Vector<::test_object::ppmr_allocator::CreatorNested>(get_allocator());
                return ::zserio::reflectableArray(m_object.nestedArray, get_allocator());
            }
            if (name == "textArray")
            {
                m_object.textArray = ::zserio::ppmr::Vector<::zserio::ppmr::String>(get_allocator());
                return ::zserio::reflectableArray(m_object.textArray, get_allocator());
            }
            if (name == "externArray")
            {
                m_object.externArray = ::zserio::ppmr::Vector<::zserio::ppmr::BitBuffer>(get_allocator());
                return ::zserio::reflectableArray(*m_object.externArray, get_allocator());
            }
            if (name == "bytesArray")
            {
                m_object.bytesArray = ::zserio::ppmr::Vector<::zserio::ppmr::Bytes>(get_allocator());
                return ::zserio::reflectableArray(*m_object.bytesArray, get_allocator());
            }
            if (name == "optionalBool")
            {
                m_object.optionalBool = ::zserio::Bool();
                return ::zserio::reflectable(*m_object.optionalBool, get_allocator());
            }
            if (name == "optionalNested")
            {
                m_object.optionalNested = ::test_object::ppmr_allocator::CreatorNested(get_allocator());
                return ::zserio::reflectable(*m_object.optionalNested, get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'CreatorObject'!";
        }

        ::zserio::ppmr::Any getAnyValue(const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& alloc) const override
        {
            return ::zserio::ppmr::Any(::std::cref(m_object), alloc);
        }

        ::zserio::ppmr::Any getAnyValue(const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& alloc) override
        {
            return ::zserio::ppmr::Any(::std::ref(m_object), alloc);
        }

    private:
        ::test_object::ppmr_allocator::CreatorObject& m_object;
    };

    return ::std::allocate_shared<ReflectableImpl>(allocator, value);
}

::zserio::ppmr::IIntrospectableViewConstPtr Introspectable<::test_object::ppmr_allocator::CreatorObject, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>::create(
        const View<::test_object::ppmr_allocator::CreatorObject>& view, const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& allocator)
{
    class IntrospectableImpl : public ::zserio::detail::CompoundIntrospectableViewBase<::test_object::ppmr_allocator::CreatorObject, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>
    {
    public:
        explicit IntrospectableImpl(const ::zserio::View<::test_object::ppmr_allocator::CreatorObject>& view_, const ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>& alloc = {}) :
                ::zserio::detail::CompoundIntrospectableViewBase<::test_object::ppmr_allocator::CreatorObject, ::zserio::ppmr::PropagatingPolymorphicAllocator<uint8_t>>(
                        view_, alloc)
        {}

        ::zserio::ppmr::IIntrospectableViewConstPtr getField(::std::string_view name) const override
        {
            if (name == "value")
            {
                return ::zserio::introspectable(getValue().value(), get_allocator());
            }
            if (name == "nested")
            {
                return ::zserio::introspectable(getValue().nested(), get_allocator());
            }
            if (name == "text")
            {
                return ::zserio::introspectable(getValue().text(), get_allocator());
            }
            if (name == "nestedArray")
            {
                return ::zserio::introspectableArray(getValue().nestedArray(), get_allocator());
            }
            if (name == "textArray")
            {
                return ::zserio::introspectableArray(getValue().textArray(), get_allocator());
            }
            if (name == "externArray")
            {
                if (!getValue().externArray().has_value())
                {
                    return nullptr;
                }

                return ::zserio::introspectableArray(*getValue().externArray(), get_allocator());
            }
            if (name == "bytesArray")
            {
                if (!getValue().bytesArray().has_value())
                {
                    return nullptr;
                }

                return ::zserio::introspectableArray(*getValue().bytesArray(), get_allocator());
            }
            if (name == "optionalBool")
            {
                if (!getValue().optionalBool().has_value())
                {
                    return nullptr;
                }

                return ::zserio::introspectable(*getValue().optionalBool(), get_allocator());
            }
            if (name == "optionalNested")
            {
                if (!getValue().optionalNested().has_value())
                {
                    return nullptr;
                }

                return ::zserio::introspectable(*getValue().optionalNested(), get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'CreatorObject'!";
        }
    };

    return ::std::allocate_shared<IntrospectableImpl>(allocator, view);
}

} // namespace detail
} // namespace zserio

namespace std
{

size_t hash<::test_object::ppmr_allocator::CreatorObject>::operator()(const ::test_object::ppmr_allocator::CreatorObject& data) const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, data.value);
    result = ::zserio::calcHashCode(result, data.nested);
    result = ::zserio::calcHashCode(result, data.text);
    result = ::zserio::calcHashCode(result, data.nestedArray);
    result = ::zserio::calcHashCode(result, data.textArray);
    result = ::zserio::calcHashCode(result, data.externArray);
    result = ::zserio::calcHashCode(result, data.bytesArray);
    result = ::zserio::calcHashCode(result, data.optionalBool);
    result = ::zserio::calcHashCode(result, data.optionalNested);
    return static_cast<size_t>(result);
}

size_t hash<::zserio::View<::test_object::ppmr_allocator::CreatorObject>>::operator()(const ::zserio::View<::test_object::ppmr_allocator::CreatorObject>& view) const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, view.value());
    result = ::zserio::calcHashCode(result, view.nested());
    result = ::zserio::calcHashCode(result, view.text());
    result = ::zserio::calcHashCode(result, view.nestedArray());
    result = ::zserio::calcHashCode(result, view.textArray());
    if (view.externArray())
    {
        result = ::zserio::calcHashCode(result, view.externArray());
    }
    if (view.bytesArray())
    {
        result = ::zserio::calcHashCode(result, view.bytesArray());
    }
    if (view.optionalBool())
    {
        result = ::zserio::calcHashCode(result, view.optionalBool());
    }
    if (view.optionalNested())
    {
        result = ::zserio::calcHashCode(result, view.optionalNested());
    }
    return static_cast<size_t>(result);
}

} // namespace std
