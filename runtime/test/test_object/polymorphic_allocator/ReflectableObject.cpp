/**
 * Automatically generated by Zserio C++17 generator version 0.1.0 using Zserio core 2.16.0.
 * Generator setup: typeInfoCode, polymorphicAllocator.
 */

#include <zserio/BitPositionUtil.h>
#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/ReflectableData.h>
#include <zserio/TypeInfo.h>

#include <test_object/polymorphic_allocator/ReflectableObject.h>

namespace test_object
{
namespace polymorphic_allocator
{

ReflectableObject::ReflectableObject() noexcept :
        ReflectableObject(AllocatorType{})
{}

ReflectableObject::ReflectableObject(const AllocatorType& allocator) noexcept :
        stringField(allocator),
        reflectableNested(allocator),
        reflectableEnum(),
        reflectableChoice(allocator),
        reflectableUnion(allocator)
{}

ReflectableObject::ReflectableObject(
        ::zserio::pmr::String stringField_,
        ::test_object::polymorphic_allocator::ReflectableNested reflectableNested_,
        ::test_object::polymorphic_allocator::ReflectableEnum reflectableEnum_,
        ::test_object::polymorphic_allocator::ReflectableChoice reflectableChoice_,
        ::test_object::polymorphic_allocator::ReflectableUnion reflectableUnion_) :
        stringField(::std::move(stringField_)),
        reflectableNested(::std::move(reflectableNested_)),
        reflectableEnum(reflectableEnum_),
        reflectableChoice(::std::move(reflectableChoice_)),
        reflectableUnion(::std::move(reflectableUnion_))
{}

bool operator==(const ::test_object::polymorphic_allocator::ReflectableObject& lhs, const ::test_object::polymorphic_allocator::ReflectableObject& rhs)
{
    return ::std::tie(
            lhs.stringField,
            lhs.reflectableNested,
            lhs.reflectableEnum,
            lhs.reflectableChoice,
            lhs.reflectableUnion)
            == ::std::tie(
            rhs.stringField,
            rhs.reflectableNested,
            rhs.reflectableEnum,
            rhs.reflectableChoice,
            rhs.reflectableUnion);
}

bool operator<(const ::test_object::polymorphic_allocator::ReflectableObject& lhs, const ::test_object::polymorphic_allocator::ReflectableObject& rhs)
{
    return ::std::tie(
            lhs.stringField,
            lhs.reflectableNested,
            lhs.reflectableEnum,
            lhs.reflectableChoice,
            lhs.reflectableUnion)
            < ::std::tie(
            rhs.stringField,
            rhs.reflectableNested,
            rhs.reflectableEnum,
            rhs.reflectableChoice,
            rhs.reflectableUnion);
}

bool operator!=(const ::test_object::polymorphic_allocator::ReflectableObject& lhs, const ::test_object::polymorphic_allocator::ReflectableObject& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const ::test_object::polymorphic_allocator::ReflectableObject& lhs, const ::test_object::polymorphic_allocator::ReflectableObject& rhs)
{
    return rhs < lhs;
}

bool operator<=(const ::test_object::polymorphic_allocator::ReflectableObject& lhs, const ::test_object::polymorphic_allocator::ReflectableObject& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const ::test_object::polymorphic_allocator::ReflectableObject& lhs, const ::test_object::polymorphic_allocator::ReflectableObject& rhs)
{
    return !(lhs < rhs);
}

} // namespace polymorphic_allocator
} // namespace test_object

namespace zserio
{

View<::test_object::polymorphic_allocator::ReflectableObject>::View(const ::test_object::polymorphic_allocator::ReflectableObject& data) noexcept :
        m_data(&data)
{}

View<::test_object::polymorphic_allocator::ReflectableObject>::View(const ::test_object::polymorphic_allocator::ReflectableObject& data,
        const View&) noexcept :
        m_data(&data)
{}

::std::string_view View<::test_object::polymorphic_allocator::ReflectableObject>::stringField() const
{
    return ::std::string_view{
            m_data->stringField};
}

View<::test_object::polymorphic_allocator::ReflectableNested> View<::test_object::polymorphic_allocator::ReflectableObject>::reflectableNested() const
{
    return View<::test_object::polymorphic_allocator::ReflectableNested>{
            m_data->reflectableNested, ::zserio::Int31(static_cast<::zserio::Int31::ValueType>(13)), stringField()};
}

::test_object::polymorphic_allocator::ReflectableEnum View<::test_object::polymorphic_allocator::ReflectableObject>::reflectableEnum() const
{
    return m_data->reflectableEnum;
}

View<::test_object::polymorphic_allocator::ReflectableChoice> View<::test_object::polymorphic_allocator::ReflectableObject>::reflectableChoice() const
{
    return View<::test_object::polymorphic_allocator::ReflectableChoice>{
            m_data->reflectableChoice, reflectableEnum()};
}

View<::test_object::polymorphic_allocator::ReflectableUnion> View<::test_object::polymorphic_allocator::ReflectableObject>::reflectableUnion() const
{
    return View<::test_object::polymorphic_allocator::ReflectableUnion>{
            m_data->reflectableUnion};
}

const ::test_object::polymorphic_allocator::ReflectableObject& View<::test_object::polymorphic_allocator::ReflectableObject>::zserioData() const
{
    return *m_data;
}

bool operator==(const View<::test_object::polymorphic_allocator::ReflectableObject>& lhs, const View<::test_object::polymorphic_allocator::ReflectableObject>& rhs)
{
    return lhs.stringField() == rhs.stringField() &&
            lhs.reflectableNested() == rhs.reflectableNested() &&
            lhs.reflectableEnum() == rhs.reflectableEnum() &&
            lhs.reflectableChoice() == rhs.reflectableChoice() &&
            lhs.reflectableUnion() == rhs.reflectableUnion();
}

bool operator<(const View<::test_object::polymorphic_allocator::ReflectableObject>& lhs, const View<::test_object::polymorphic_allocator::ReflectableObject>& rhs)
{
    if (lhs.stringField() != rhs.stringField())
    {
        return lhs.stringField() < rhs.stringField();
    }
    if (lhs.reflectableNested() != rhs.reflectableNested())
    {
        return lhs.reflectableNested() < rhs.reflectableNested();
    }
    if (lhs.reflectableEnum() != rhs.reflectableEnum())
    {
        return lhs.reflectableEnum() < rhs.reflectableEnum();
    }
    if (lhs.reflectableChoice() != rhs.reflectableChoice())
    {
        return lhs.reflectableChoice() < rhs.reflectableChoice();
    }
    if (lhs.reflectableUnion() != rhs.reflectableUnion())
    {
        return lhs.reflectableUnion() < rhs.reflectableUnion();
    }

    return false;
}

bool operator!=(const View<::test_object::polymorphic_allocator::ReflectableObject>& lhs, const View<::test_object::polymorphic_allocator::ReflectableObject>& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const View<::test_object::polymorphic_allocator::ReflectableObject>& lhs, const View<::test_object::polymorphic_allocator::ReflectableObject>& rhs)
{
    return rhs < lhs;
}

bool operator<=(const View<::test_object::polymorphic_allocator::ReflectableObject>& lhs, const View<::test_object::polymorphic_allocator::ReflectableObject>& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const View<::test_object::polymorphic_allocator::ReflectableObject>& lhs, const View<::test_object::polymorphic_allocator::ReflectableObject>& rhs)
{
    return !(lhs < rhs);
}

namespace detail
{

template <>
void validate(const View<::test_object::polymorphic_allocator::ReflectableObject>& view, ::std::string_view)
{
    validate(view.stringField(), "'ReflectableObject.stringField'");
    validate(view.reflectableNested(), "'ReflectableObject.reflectableNested'");
    validate(view.reflectableEnum(), "'ReflectableObject.reflectableEnum'");
    validate(view.reflectableChoice(), "'ReflectableObject.reflectableChoice'");
    validate(view.reflectableUnion(), "'ReflectableObject.reflectableUnion'");
}

template <>
BitSize bitSizeOf(const View<::test_object::polymorphic_allocator::ReflectableObject>& view, BitSize bitPosition)
{
    BitSize endBitPosition = bitPosition;

    auto stringField_ = view.stringField();
    endBitPosition += bitSizeOf(stringField_, endBitPosition);
    auto reflectableNested_ = view.reflectableNested();
    endBitPosition += bitSizeOf(reflectableNested_, endBitPosition);
    auto reflectableEnum_ = view.reflectableEnum();
    endBitPosition += bitSizeOf(reflectableEnum_, endBitPosition);
    auto reflectableChoice_ = view.reflectableChoice();
    endBitPosition += bitSizeOf(reflectableChoice_, endBitPosition);
    auto reflectableUnion_ = view.reflectableUnion();
    endBitPosition += bitSizeOf(reflectableUnion_, endBitPosition);

    return endBitPosition - bitPosition;
}

template <>
void write(BitStreamWriter& writer, const View<::test_object::polymorphic_allocator::ReflectableObject>& view)
{
    auto stringField_ = view.stringField();
    write(writer, stringField_);
    auto reflectableNested_ = view.reflectableNested();
    write(writer, reflectableNested_);
    auto reflectableEnum_ = view.reflectableEnum();
    write(writer, reflectableEnum_);
    auto reflectableChoice_ = view.reflectableChoice();
    write(writer, reflectableChoice_);
    auto reflectableUnion_ = view.reflectableUnion();
    write(writer, reflectableUnion_);
}

template <>
View<::test_object::polymorphic_allocator::ReflectableObject> read(BitStreamReader& reader, ::test_object::polymorphic_allocator::ReflectableObject& data)
{
    View<::test_object::polymorphic_allocator::ReflectableObject> view(data);
    read(reader, data.stringField);
    (void)read(reader, data.reflectableNested, ::zserio::Int31(static_cast<::zserio::Int31::ValueType>(13)), view.stringField());
    read(reader, data.reflectableEnum);
    (void)read(reader, data.reflectableChoice, view.reflectableEnum());
    (void)read(reader, data.reflectableUnion);
    return view;
}

const ::zserio::pmr::ITypeInfo& TypeInfo<::test_object::polymorphic_allocator::ReflectableObject, ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>::get()
{
    using AllocatorType = ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>;

    static const ::std::string_view templateName;
    static const ::zserio::Span<::zserio::BasicTemplateArgumentInfo<AllocatorType>> templateArguments;

    static const ::std::array<::std::string_view, 2> reflectableNestedTypeArguments = {
        "13",
        "stringField()"
    };
    static const ::std::array<::std::string_view, 1> reflectableChoiceTypeArguments = {
        "reflectableEnum()"
    };
    static const ::std::array<::zserio::BasicFieldInfo<AllocatorType>, 5> fields = {
        ::zserio::BasicFieldInfo<AllocatorType>{
            "stringField", // schemaName
            ::zserio::typeInfo<::zserio::pmr::String, ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "reflectableNested", // schemaName
            ::zserio::typeInfo<::test_object::polymorphic_allocator::ReflectableNested, ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            reflectableNestedTypeArguments, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "reflectableEnum", // schemaName
            ::zserio::typeInfo<::test_object::polymorphic_allocator::ReflectableEnum, ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "reflectableChoice", // schemaName
            ::zserio::typeInfo<::test_object::polymorphic_allocator::ReflectableChoice, ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            reflectableChoiceTypeArguments, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "reflectableUnion", // schemaName
            ::zserio::typeInfo<::test_object::polymorphic_allocator::ReflectableUnion, ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        }
    };

    static const ::zserio::Span<::zserio::BasicParameterInfo<AllocatorType>> parameters;

    static const ::zserio::Span<::zserio::BasicFunctionInfo<AllocatorType>> functions;

    static const ::zserio::detail::StructTypeInfo<AllocatorType> typeInfo = {
        "test_object.polymorphic_allocator.ReflectableObject",
        [](const AllocatorType& allocator) -> ::zserio::pmr::IReflectableDataPtr
        {
            return std::allocate_shared<::zserio::ReflectableDataOwner<::test_object::polymorphic_allocator::ReflectableObject>>(allocator, allocator);
        },
        templateName, templateArguments, fields, parameters, functions
    };

    return typeInfo;
}

} // namespace detail

template <>
::zserio::pmr::IReflectableDataConstPtr reflectable(
        const ::test_object::polymorphic_allocator::ReflectableObject& object, const ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>& allocator)
{
    class Reflectable : public ::zserio::ReflectableDataConstAllocatorHolderBase<::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>
    {
    public:
        using ::zserio::ReflectableDataConstAllocatorHolderBase<::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>::getField;
        using ::zserio::ReflectableDataConstAllocatorHolderBase<::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>::getAnyValue;

        explicit Reflectable(const ::test_object::polymorphic_allocator::ReflectableObject& object_, const ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>& alloc) :
                ::zserio::ReflectableDataConstAllocatorHolderBase<::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>(typeInfo<::test_object::polymorphic_allocator::ReflectableObject>(), alloc),
                m_object(object_)
        {}

        ::zserio::pmr::IReflectableDataConstPtr getField(::std::string_view name) const override
        {
            if (name == "stringField")
            {
                return ::zserio::reflectable(m_object.stringField, get_allocator());
            }
            if (name == "reflectableNested")
            {
                return ::zserio::reflectable(m_object.reflectableNested, get_allocator());
            }
            if (name == "reflectableEnum")
            {
                return ::zserio::reflectable(m_object.reflectableEnum, get_allocator());
            }
            if (name == "reflectableChoice")
            {
                return ::zserio::reflectable(m_object.reflectableChoice, get_allocator());
            }
            if (name == "reflectableUnion")
            {
                return ::zserio::reflectable(m_object.reflectableUnion, get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'ReflectableObject'!";
        }

        ::zserio::pmr::Any getAnyValue(const ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>& alloc) const override
        {
            return ::zserio::pmr::Any(::std::cref(m_object), alloc);
        }

    private:
        const ::test_object::polymorphic_allocator::ReflectableObject& m_object;
    };

    return std::allocate_shared<Reflectable>(allocator, object, allocator);
}

template <>
::zserio::pmr::IReflectableDataPtr reflectable(
        ::test_object::polymorphic_allocator::ReflectableObject& object, const ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>& allocator)
{
    class Reflectable : public ::zserio::ReflectableDataAllocatorHolderBase<::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>
    {
    public:
        using ::zserio::ReflectableDataAllocatorHolderBase<::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>::getField;
        using ::zserio::ReflectableDataAllocatorHolderBase<::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>::getAnyValue;

        explicit Reflectable(::test_object::polymorphic_allocator::ReflectableObject& object_, const ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>& alloc) :
                ::zserio::ReflectableDataAllocatorHolderBase<::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>>(typeInfo<::test_object::polymorphic_allocator::ReflectableObject>(), alloc),
                m_object(object_)
        {}

        ::zserio::pmr::IReflectableDataConstPtr getField(::std::string_view name) const override
        {
            if (name == "stringField")
            {
                return ::zserio::reflectable(m_object.stringField, get_allocator());
            }
            if (name == "reflectableNested")
            {
                return ::zserio::reflectable(m_object.reflectableNested, get_allocator());
            }
            if (name == "reflectableEnum")
            {
                return ::zserio::reflectable(m_object.reflectableEnum, get_allocator());
            }
            if (name == "reflectableChoice")
            {
                return ::zserio::reflectable(m_object.reflectableChoice, get_allocator());
            }
            if (name == "reflectableUnion")
            {
                return ::zserio::reflectable(m_object.reflectableUnion, get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'ReflectableObject'!";
        }

        ::zserio::pmr::IReflectableDataPtr getField(::std::string_view name) override
        {
            if (name == "stringField")
            {
                return ::zserio::reflectable(m_object.stringField, get_allocator());
            }
            if (name == "reflectableNested")
            {
                return ::zserio::reflectable(m_object.reflectableNested, get_allocator());
            }
            if (name == "reflectableEnum")
            {
                return ::zserio::reflectable(m_object.reflectableEnum, get_allocator());
            }
            if (name == "reflectableChoice")
            {
                return ::zserio::reflectable(m_object.reflectableChoice, get_allocator());
            }
            if (name == "reflectableUnion")
            {
                return ::zserio::reflectable(m_object.reflectableUnion, get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'ReflectableObject'!";
        }

        void setField(::std::string_view name, const ::zserio::pmr::Any& value) override
        {
            if (name == "stringField")
            {
                m_object.stringField = value.get<::zserio::pmr::String>();
                return;
            }
            if (name == "reflectableNested")
            {
                m_object.reflectableNested = value.get<::test_object::polymorphic_allocator::ReflectableNested>();
                return;
            }
            if (name == "reflectableEnum")
            {
                if (value.isType<::test_object::polymorphic_allocator::ReflectableEnum>())
                {
                    m_object.reflectableEnum = value.get<::test_object::polymorphic_allocator::ReflectableEnum>();
                }
                else if (value.isType<typename EnumTraits<::test_object::polymorphic_allocator::ReflectableEnum>::ZserioType>())
                {
                    m_object.reflectableEnum =
                            valueToEnum<::test_object::polymorphic_allocator::ReflectableEnum>(value.get<typename EnumTraits<::test_object::polymorphic_allocator::ReflectableEnum>::ZserioType>());
                }
                else
                {
                    m_object.reflectableEnum =
                            valueToEnum<::test_object::polymorphic_allocator::ReflectableEnum>(value.get<std::underlying_type_t<::test_object::polymorphic_allocator::ReflectableEnum>>());
                }
                return;
            }
            if (name == "reflectableChoice")
            {
                m_object.reflectableChoice = value.get<::test_object::polymorphic_allocator::ReflectableChoice>();
                return;
            }
            if (name == "reflectableUnion")
            {
                m_object.reflectableUnion = value.get<::test_object::polymorphic_allocator::ReflectableUnion>();
                return;
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'ReflectableObject'!";
        }

        ::zserio::pmr::IReflectableDataPtr createField(::std::string_view name) override
        {
            if (name == "stringField")
            {
                m_object.stringField = ::zserio::pmr::String(get_allocator());
                return ::zserio::reflectable(m_object.stringField, get_allocator());
            }
            if (name == "reflectableNested")
            {
                m_object.reflectableNested = ::test_object::polymorphic_allocator::ReflectableNested(get_allocator());
                return ::zserio::reflectable(m_object.reflectableNested, get_allocator());
            }
            if (name == "reflectableEnum")
            {
                m_object.reflectableEnum = ::test_object::polymorphic_allocator::ReflectableEnum();
                return ::zserio::reflectable(m_object.reflectableEnum, get_allocator());
            }
            if (name == "reflectableChoice")
            {
                m_object.reflectableChoice = ::test_object::polymorphic_allocator::ReflectableChoice(get_allocator());
                return ::zserio::reflectable(m_object.reflectableChoice, get_allocator());
            }
            if (name == "reflectableUnion")
            {
                m_object.reflectableUnion = ::test_object::polymorphic_allocator::ReflectableUnion(get_allocator());
                return ::zserio::reflectable(m_object.reflectableUnion, get_allocator());
            }
            throw ::zserio::CppRuntimeException("Field '") << name << "' doesn't exist in 'ReflectableObject'!";
        }

        ::zserio::pmr::Any getAnyValue(const ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>& alloc) const override
        {
            return ::zserio::pmr::Any(::std::cref(m_object), alloc);
        }

        ::zserio::pmr::Any getAnyValue(const ::zserio::pmr::PropagatingPolymorphicAllocator<uint8_t>& alloc) override
        {
            return ::zserio::pmr::Any(::std::ref(m_object), alloc);
        }

    private:
        ::test_object::polymorphic_allocator::ReflectableObject& m_object;
    };

    return std::allocate_shared<Reflectable>(allocator, object, allocator);
}

} // namespace zserio

namespace std
{

size_t hash<::test_object::polymorphic_allocator::ReflectableObject>::operator()(const ::test_object::polymorphic_allocator::ReflectableObject& data) const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, data.stringField);
    result = ::zserio::calcHashCode(result, data.reflectableNested);
    result = ::zserio::calcHashCode(result, data.reflectableEnum);
    result = ::zserio::calcHashCode(result, data.reflectableChoice);
    result = ::zserio::calcHashCode(result, data.reflectableUnion);
    return static_cast<size_t>(result);
}

size_t hash<::zserio::View<::test_object::polymorphic_allocator::ReflectableObject>>::operator()(const ::zserio::View<::test_object::polymorphic_allocator::ReflectableObject>& view) const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, view.stringField());
    result = ::zserio::calcHashCode(result, view.reflectableNested());
    result = ::zserio::calcHashCode(result, view.reflectableEnum());
    result = ::zserio::calcHashCode(result, view.reflectableChoice());
    result = ::zserio::calcHashCode(result, view.reflectableUnion());
    return static_cast<size_t>(result);
}

} // namespace std
