/**
 * Automatically generated by Zserio C++17 generator version 0.1.0 using Zserio core 2.16.0.
 * Generator setup: typeInfoCode, stdAllocator.
 */

#include <zserio/BitPositionUtil.h>
#include <zserio/BitStreamReader.h>
#include <zserio/BitStreamWriter.h>
#include <zserio/HashCodeUtil.h>
#include <zserio/TypeInfo.h>

#include <test_object/std_allocator/ReflectableUtilObject.h>

namespace test_object
{
namespace std_allocator
{

ReflectableUtilObject::ReflectableUtilObject() noexcept :
        ReflectableUtilObject(AllocatorType{})
{}

ReflectableUtilObject::ReflectableUtilObject(const AllocatorType& allocator) noexcept :
        choiceParam(),
        reflectableUtilChoice(allocator)
{}

ReflectableUtilObject::ReflectableUtilObject(
        ::zserio::UInt8 choiceParam_,
        ::test_object::std_allocator::ReflectableUtilChoice reflectableUtilChoice_) :
        choiceParam(choiceParam_),
        reflectableUtilChoice(::std::move(reflectableUtilChoice_))
{}

bool operator==(const ::test_object::std_allocator::ReflectableUtilObject& lhs, const ::test_object::std_allocator::ReflectableUtilObject& rhs)
{
    return ::std::tie(
            lhs.choiceParam,
            lhs.reflectableUtilChoice)
            == ::std::tie(
            rhs.choiceParam,
            rhs.reflectableUtilChoice);
}

bool operator<(const ::test_object::std_allocator::ReflectableUtilObject& lhs, const ::test_object::std_allocator::ReflectableUtilObject& rhs)
{
    return ::std::tie(
            lhs.choiceParam,
            lhs.reflectableUtilChoice)
            < ::std::tie(
            rhs.choiceParam,
            rhs.reflectableUtilChoice);
}

bool operator!=(const ::test_object::std_allocator::ReflectableUtilObject& lhs, const ::test_object::std_allocator::ReflectableUtilObject& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const ::test_object::std_allocator::ReflectableUtilObject& lhs, const ::test_object::std_allocator::ReflectableUtilObject& rhs)
{
    return rhs < lhs;
}

bool operator<=(const ::test_object::std_allocator::ReflectableUtilObject& lhs, const ::test_object::std_allocator::ReflectableUtilObject& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const ::test_object::std_allocator::ReflectableUtilObject& lhs, const ::test_object::std_allocator::ReflectableUtilObject& rhs)
{
    return !(lhs < rhs);
}

} // namespace std_allocator
} // namespace test_object

namespace zserio
{

View<::test_object::std_allocator::ReflectableUtilObject>::View(const ::test_object::std_allocator::ReflectableUtilObject& data) noexcept :
        m_data(&data)
{}

View<::test_object::std_allocator::ReflectableUtilObject>::View(const ::test_object::std_allocator::ReflectableUtilObject& data,
        const View&) noexcept :
        m_data(&data)
{}

::zserio::UInt8 View<::test_object::std_allocator::ReflectableUtilObject>::choiceParam() const
{
    return m_data->choiceParam;
}

View<::test_object::std_allocator::ReflectableUtilChoice> View<::test_object::std_allocator::ReflectableUtilObject>::reflectableUtilChoice() const
{
    return View<::test_object::std_allocator::ReflectableUtilChoice>{
            m_data->reflectableUtilChoice, ::zserio::UInt8(static_cast<::zserio::UInt8::ValueType>(choiceParam()))};
}

const ::test_object::std_allocator::ReflectableUtilObject& View<::test_object::std_allocator::ReflectableUtilObject>::zserioData() const
{
    return *m_data;
}

bool operator==(const View<::test_object::std_allocator::ReflectableUtilObject>& lhs, const View<::test_object::std_allocator::ReflectableUtilObject>& rhs)
{
    return lhs.choiceParam() == rhs.choiceParam() &&
            lhs.reflectableUtilChoice() == rhs.reflectableUtilChoice();
}

bool operator<(const View<::test_object::std_allocator::ReflectableUtilObject>& lhs, const View<::test_object::std_allocator::ReflectableUtilObject>& rhs)
{
    if (lhs.choiceParam() != rhs.choiceParam())
    {
        return lhs.choiceParam() < rhs.choiceParam();
    }
    if (lhs.reflectableUtilChoice() != rhs.reflectableUtilChoice())
    {
        return lhs.reflectableUtilChoice() < rhs.reflectableUtilChoice();
    }

    return false;
}

bool operator!=(const View<::test_object::std_allocator::ReflectableUtilObject>& lhs, const View<::test_object::std_allocator::ReflectableUtilObject>& rhs)
{
    return !(lhs == rhs);
}

bool operator>(const View<::test_object::std_allocator::ReflectableUtilObject>& lhs, const View<::test_object::std_allocator::ReflectableUtilObject>& rhs)
{
    return rhs < lhs;
}

bool operator<=(const View<::test_object::std_allocator::ReflectableUtilObject>& lhs, const View<::test_object::std_allocator::ReflectableUtilObject>& rhs)
{
    return !(rhs < lhs);
}

bool operator>=(const View<::test_object::std_allocator::ReflectableUtilObject>& lhs, const View<::test_object::std_allocator::ReflectableUtilObject>& rhs)
{
    return !(lhs < rhs);
}

namespace detail
{

template <>
void validate(const View<::test_object::std_allocator::ReflectableUtilObject>& view, ::std::string_view)
{
    validate(view.choiceParam(), "'ReflectableUtilObject.choiceParam'");
    validate(view.reflectableUtilChoice(), "'ReflectableUtilObject.reflectableUtilChoice'");
}

template <>
BitSize bitSizeOf(const View<::test_object::std_allocator::ReflectableUtilObject>& view, BitSize bitPosition)
{
    BitSize endBitPosition = bitPosition;

    auto choiceParam_ = view.choiceParam();
    endBitPosition += bitSizeOf(choiceParam_, endBitPosition);
    auto reflectableUtilChoice_ = view.reflectableUtilChoice();
    endBitPosition += bitSizeOf(reflectableUtilChoice_, endBitPosition);

    return endBitPosition - bitPosition;
}

template <>
void write(BitStreamWriter& writer, const View<::test_object::std_allocator::ReflectableUtilObject>& view)
{
    auto choiceParam_ = view.choiceParam();
    write(writer, choiceParam_);
    auto reflectableUtilChoice_ = view.reflectableUtilChoice();
    write(writer, reflectableUtilChoice_);
}

template <>
View<::test_object::std_allocator::ReflectableUtilObject> read(BitStreamReader& reader, ::test_object::std_allocator::ReflectableUtilObject& data)
{
    View<::test_object::std_allocator::ReflectableUtilObject> view(data);
    read(reader, data.choiceParam);
    (void)read(reader, data.reflectableUtilChoice, ::zserio::UInt8(static_cast<::zserio::UInt8::ValueType>(view.choiceParam())));
    return view;
}

const ::zserio::ITypeInfo& TypeInfo<::test_object::std_allocator::ReflectableUtilObject, ::std::allocator<uint8_t>>::get()
{
    using AllocatorType = ::std::allocator<uint8_t>;

    static const ::std::string_view templateName;
    static const ::zserio::Span<::zserio::BasicTemplateArgumentInfo<AllocatorType>> templateArguments;

    static const ::std::array<::std::string_view, 1> reflectableUtilChoiceTypeArguments = {
        "choiceParam()"
    };
    static const ::std::array<::zserio::BasicFieldInfo<AllocatorType>, 2> fields = {
        ::zserio::BasicFieldInfo<AllocatorType>{
            "choiceParam", // schemaName
            ::zserio::typeInfo<::zserio::UInt8, ::std::allocator<uint8_t>>(), // typeInfo
            {}, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        },
        ::zserio::BasicFieldInfo<AllocatorType>{
            "reflectableUtilChoice", // schemaName
            ::zserio::typeInfo<::test_object::std_allocator::ReflectableUtilChoice, ::std::allocator<uint8_t>>(), // typeInfo
            reflectableUtilChoiceTypeArguments, // typeArguments
            false, // isExtended
            {}, // alignment
            {}, // offset
            {}, // initializer
            false, // isOptional
            {}, // optionalClause
            {}, // constraint
            false, // isArray
            {}, // arrayLength
            false, // isPacked
            false // isImplicit
        }
    };

    static const ::zserio::Span<::zserio::BasicParameterInfo<AllocatorType>> parameters;

    static const ::zserio::Span<::zserio::BasicFunctionInfo<AllocatorType>> functions;

    static const ::zserio::detail::StructTypeInfo<AllocatorType> typeInfo = {
        "test_object.std_allocator.ReflectableUtilObject", nullptr,
        templateName, templateArguments, fields, parameters, functions
    };

    return typeInfo;
}

} // namespace detail
} // namespace zserio

namespace std
{

size_t hash<::test_object::std_allocator::ReflectableUtilObject>::operator()(const ::test_object::std_allocator::ReflectableUtilObject& data) const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, data.choiceParam);
    result = ::zserio::calcHashCode(result, data.reflectableUtilChoice);
    return static_cast<size_t>(result);
}

size_t hash<::zserio::View<::test_object::std_allocator::ReflectableUtilObject>>::operator()(const ::zserio::View<::test_object::std_allocator::ReflectableUtilObject>& view) const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result, view.choiceParam());
    result = ::zserio::calcHashCode(result, view.reflectableUtilChoice());
    return static_cast<size_t>(result);
}

} // namespace std
