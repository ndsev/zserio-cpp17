/**
 * Automatically generated by Zserio C++17 generator version 0.3.0 using Zserio core 2.16.0.
 * Generator setup: typeInfoCode, stdAllocator.
 */

#include <zserio/HashCodeUtil.h>
#include <zserio/StringConvertUtil.h>
#include <zserio/IntrospectableView.h>
#include <zserio/ReflectableData.h>
#include <zserio/TypeInfo.h>

#include <test_object/std_allocator/ReflectableUtilBitmask.h>

namespace test_object
{
namespace std_allocator
{

::zserio::String ReflectableUtilBitmask::toString(const ::zserio::String::allocator_type& allocator) const
{
    ::zserio::String result(allocator);
    if ((*this & ReflectableUtilBitmask::Values::READ) == ReflectableUtilBitmask::Values::READ)
    {
        result += result.empty() ? "READ" : " | READ";
    }
    if ((*this & ReflectableUtilBitmask::Values::WRITE) == ReflectableUtilBitmask::Values::WRITE)
    {
        result += result.empty() ? "WRITE" : " | WRITE";
    }

    return ::zserio::toString<::zserio::String::allocator_type>(
            static_cast<ZserioType::ValueType>(m_value), allocator) + "[" + result + "]";
}

} // namespace std_allocator
} // namespace test_object

namespace zserio
{
namespace detail
{

const ::zserio::ITypeInfo& TypeInfo<::test_object::std_allocator::ReflectableUtilBitmask, ::std::allocator<uint8_t>>::get()
{
    using AllocatorType = ::std::allocator<uint8_t>;

    static const ::std::array<::zserio::ItemInfo, 2> values = {
        ::zserio::ItemInfo{ "READ", static_cast<uint64_t>(UINT8_C(1)), false, false},
        ::zserio::ItemInfo{ "WRITE", static_cast<uint64_t>(UINT8_C(2)), false, false}
    };

    static const ::zserio::detail::BitmaskTypeInfo<AllocatorType> typeInfo = {
        "test_object.std_allocator.ReflectableUtilBitmask",
        ::zserio::typeInfo<::zserio::UInt8, ::std::allocator<uint8_t>>(),
        values
    };

    return typeInfo;
}

} // namespace detail

template <>
::zserio::IReflectableDataPtr reflectable(::test_object::std_allocator::ReflectableUtilBitmask value, const ::std::allocator<uint8_t>& allocator)
{
    class Reflectable : public ::zserio::detail::ReflectableDataBase<::std::allocator<uint8_t>>
    {
    public:
        using ::zserio::detail::ReflectableDataBase<::std::allocator<uint8_t>>::getAnyValue;

        explicit Reflectable(::test_object::std_allocator::ReflectableUtilBitmask bitmask) :
                ::zserio::detail::ReflectableDataBase<::std::allocator<uint8_t>>(
                        typeInfo<::test_object::std_allocator::ReflectableUtilBitmask, ::std::allocator<uint8_t>>()),
                m_bitmask(bitmask)
        {}

        ::zserio::Any getAnyValue(const ::std::allocator<uint8_t>& alloc) const override
        {
            return ::zserio::Any(m_bitmask, alloc);
        }

        ::zserio::Any getAnyValue(const ::std::allocator<uint8_t>& alloc) override
        {
            return ::zserio::Any(m_bitmask, alloc);
        }

        ::test_object::std_allocator::ReflectableUtilBitmask::ZserioType::ValueType getUInt8() const override
        {
            return m_bitmask.getValue();
        }

        uint64_t toUInt() const override
        {
            return m_bitmask.getValue();
        }

        double toDouble() const override
        {
            return static_cast<double>(toUInt());
        }

        ::zserio::String toString(const ::std::allocator<uint8_t>& alloc) const override
        {
            return m_bitmask.toString(alloc);
        }

    private:
        ::test_object::std_allocator::ReflectableUtilBitmask m_bitmask;
    };

    return ::std::allocate_shared<Reflectable>(allocator, value);
}

template <>
::zserio::IIntrospectableViewConstPtr introspectable(::test_object::std_allocator::ReflectableUtilBitmask value, const ::std::allocator<uint8_t>& allocator)
{
    class Introspectable : public ::zserio::detail::IntrospectableViewBase<::test_object::std_allocator::ReflectableUtilBitmask, ::std::allocator<uint8_t>>
    {
    public:
        explicit Introspectable(::test_object::std_allocator::ReflectableUtilBitmask bitmask) :
                ::zserio::detail::IntrospectableViewBase<::test_object::std_allocator::ReflectableUtilBitmask, ::std::allocator<uint8_t>>(
                        typeInfo<::test_object::std_allocator::ReflectableUtilBitmask, ::std::allocator<uint8_t>>(), bitmask)
        {}
        ::test_object::std_allocator::ReflectableUtilBitmask::ZserioType::ValueType getUInt8() const override
        {
            return getValue().getValue();
        }

        uint64_t toUInt() const override
        {
            return getValue().getValue();
        }

        double toDouble() const override
        {
            return static_cast<double>(toUInt());
        }

        ::zserio::String toString(const ::std::allocator<uint8_t>& alloc) const override
        {
            return getValue().toString(alloc);
        }
    };

    return ::std::allocate_shared<Introspectable>(allocator, value);
}

} // namespace zserio

namespace std
{

size_t hash<::test_object::std_allocator::ReflectableUtilBitmask>::operator()(const ::test_object::std_allocator::ReflectableUtilBitmask& value) const
{
    uint32_t result = ::zserio::HASH_SEED;
    result = ::zserio::calcHashCode(result,
            static_cast<::test_object::std_allocator::ReflectableUtilBitmask::ZserioType::ValueType>(value.getValue()));
    return static_cast<size_t>(result);
}

} // namespace std
