#ifndef ZSERIO_ARRAY_H_INC
#define ZSERIO_ARRAY_H_INC

#include <type_traits>

#include "zserio/ArrayTraits.h"
#include "zserio/BitPositionUtil.h"
#include "zserio/BitStreamReader.h"
#include "zserio/BitStreamWriter.h"

namespace zserio
{

/**
 * Array type enum which defined type of the underlying array.
 */
enum ArrayType
{
    NORMAL, /**< Normal zserio array which has size defined by the Zserio schema. */
    IMPLICIT, /**< Implicit zserio array which size is defined by number of remaining bits in the bit stream. */
    ALIGNED, /**< Aligned zserio array which is normal zserio array with indexed offsets. */
    AUTO, /**< Auto zserio array which has size stored in a hidden field before the array. */
    ALIGNED_AUTO /**< Aligned auto zserio array which is auto zserio array with indexed offsets. */
};

template <typename RAW_ARRAY, ArrayType ARRAY_TYPE,
        typename ARRAY_TRAITS = ArrayTraits<typename RAW_ARRAY::value_type>>
class Array
{
public:
    /** Array type. */
    static constexpr ArrayType TYPE = ARRAY_TYPE;

    /** Typedef for the raw array. */
    using RawArray = RAW_ARRAY;

    /** Typedef for the value type. */
    using ValueType = typename RawArray::value_type;

    /** Typedef for allocator type. */
    using allocator_type = typename RawArray::allocator_type;

    /** Typedef for the array traits. */
    using Traits = ARRAY_TRAITS;

    /**
     * Typedef for the array's owner type.
     *
     * Owner type is needed for proper expressions evaluation. If no owner is needed for expressions evaluation,
     * detail::DummyArrayOwner is used.
     */
    using OwnerType = detail::array_owner_type_t<Traits>;

    /**
     * Constructor from l-value raw array.
     *
     * \param owner View to the array's owner.
     * \param rawArray Raw array.
     */
    template <typename OWNER_TYPE_ = OwnerType, std::enable_if_t<!detail::is_dummy_v<OWNER_TYPE_>, int> = 0>
    explicit Array(const OwnerType& owner, const RawArray& rawArray) :
            m_owner(owner),
            m_rawArray(rawArray)
    {}

    /**
     * Constructor from l-value raw array.
     *
     * \param rawArray Raw array.
     */
    template <typename OWNER_TYPE_ = OwnerType, std::enable_if_t<detail::is_dummy_v<OWNER_TYPE_>, int> = 0>
    explicit Array(const RawArray& rawArray) :
            m_rawArray(rawArray)
    {}

    /**
     * Method generated by default.
     *
     * \{
     */
    ~Array() = default;
    Array(const Array& other) = default;
    Array& operator=(const Array& other) = default;
    Array(Array&& other) = default;
    Array& operator=(Array&& other) = default;
    /**
     * \}
     */

    /**
     * Operator equality.
     *
     * \param other Array to compare.
     *
     * \return True when the underlying raw arrays have same contents, false otherwise.
     */
    bool operator==(const Array& other) const
    {
        if constexpr (std::is_same_v<zserio::View<ValueType>,
                              std::invoke_result_t<decltype(&Array::at), Array, size_t>>)
        {
            const size_t thisSize = size();
            const size_t otherSize = other.size();
            if (thisSize != otherSize)
            {
                return false;
            }

            for (size_t i = 0; i < thisSize; ++i)
            {
                if ((*this)[i] != other[i])
                {
                    return false;
                }
            }

            return true;
        }
        else
        {
            return m_rawArray == other.m_rawArray;
        }
    }

    /**
     * Operator less than.
     *
     * \param other Array to compare.
     *
     * \return True when this array is less than the other array, false otherwise.
     */
    bool operator<(const Array& other) const
    {
        if constexpr (std::is_same_v<zserio::View<ValueType>,
                              std::invoke_result_t<decltype(&Array::at), Array, size_t>>)
        {
            const size_t thisSize = size();
            const size_t otherSize = other.size();
            const size_t maxSize = std::max(thisSize, otherSize);

            for (size_t i = 0; i < maxSize; ++i)
            {
                if ((*this)[i] < other[i])
                {
                    return true;
                }
                if (other[i] < (*this)[i])
                {
                    return false;
                }
            }

            return thisSize < otherSize;
        }
        else
        {
            return m_rawArray < other.m_rawArray;
        }
    }

    /**
     * Operator inequality.
     *
     * \param other Array to compare.
     *
     * \return True when the arrays have different contents, false otherwise.
     */
    bool operator!=(const Array& other) const
    {
        return !operator==(other);
    }

    /**
     * Operator greater than.
     *
     * \param other Array to compare.
     *
     * \return True when this arrays is greater than the other array, false otherwise.
     */
    bool operator>(const Array& other) const
    {
        return other.operator<(*this);
    }

    /**
     * Operator less than or equal.
     *
     * \param other Array to compare.
     *
     * \return True when this arrays is less than or equal to the other array, false otherwise.
     */
    bool operator<=(const Array& other) const
    {
        return !other.operator<(*this);
    }

    /**
     * Operator greater than or equal.
     *
     * \param other Array to compare.
     *
     * \return True when this arrays is greater than or equal to the other array, false otherwise.
     */
    bool operator>=(const Array& other) const
    {
        return !operator<(other);
    }

    /**
     * Gets length of the array.
     *
     * \return Length of the array.
     */
    size_t size() const
    {
        return m_rawArray.size();
    }

    /**
     * Returns element view at the given index.
     *
     * \param index Element index.
     * \return View to the specified element.
     */
    decltype(auto) at(size_t index) const
    {
        return Traits::at(m_owner, m_rawArray.at(index), index);
    }

    /**
     * Returns element view at the given index.
     * Like STL vector's operator[] this is does not check the array size.
     *
     * \param index Element index.
     * \return View to the specified element.
     */
    decltype(auto) operator[](size_t index) const
    {
        return Traits::at(m_owner, m_rawArray[index], index);
    }

private:
    OwnerType m_owner; // view to owner type, parameters are copied by value and that is ok
    const RawArray& m_rawArray;
};

namespace detail
{

template <typename ARRAY>
size_t readArrayLength(BitStreamReader& reader, size_t arrayLength)
{
    if constexpr (ARRAY::TYPE != ArrayType::AUTO && ARRAY::TYPE != ArrayType::ALIGNED_AUTO &&
            ARRAY::TYPE != ArrayType::IMPLICIT)
    {
        return arrayLength;
    }
    else if constexpr (ARRAY::TYPE == ArrayType::AUTO || ARRAY::TYPE == ArrayType::ALIGNED_AUTO)
    {
        return reader.readVarSize();
    }
    else
    {
        using ArrayTraits = typename ARRAY::Traits;

        const size_t remainingBits = reader.getBufferBitSize() - reader.getBitPosition();
        return remainingBits / ArrayTraits::bitSizeOf();
    }
}

template <typename ARRAY>
void read(BitStreamReader& reader, typename ARRAY::OwnerType& owner, typename ARRAY::RawArray& rawArray,
        size_t arrayLength = 0)
{
    using ArrayTraits = typename ARRAY::Traits;

    const size_t readLength = readArrayLength<ARRAY>(reader, arrayLength);
    rawArray.clear();
    rawArray.reserve(readLength);
    for (size_t i = 0; i < readLength; ++i)
    {
        if constexpr (ARRAY::TYPE == ArrayType::ALIGNED || ARRAY::TYPE == ArrayType::ALIGNED_AUTO)
        {
            reader.alignTo(8);
        }
        rawArray.push_back(typename ARRAY::ValueType{});
        ArrayTraits::read(reader, owner, rawArray.back(), i);
    }
}

template <typename ARRAY, std::enable_if_t<is_dummy_v<typename ARRAY::OwnerType>, int> = 0>
void read(BitStreamReader& reader, typename ARRAY::RawArray& rawArray, size_t arrayLength = 0)
{
    DummyArrayOwner owner;
    read<ARRAY>(reader, owner, rawArray, arrayLength);
}

template <typename RAW_ARRAY, ArrayType ARRAY_TYPE, typename ARRAY_TRAITS>
void write(BitStreamWriter& writer, const Array<RAW_ARRAY, ARRAY_TYPE, ARRAY_TRAITS>& array)
{
    if constexpr (ARRAY_TYPE == ArrayType::AUTO || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
    {
        write(writer, fromCheckedValue<VarSize>(convertSizeToUInt32(array.size())));
    }

    for (size_t i = 0; i < array.size(); ++i)
    {
        if constexpr (ARRAY_TYPE == ArrayType::ALIGNED || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
        {
            writer.alignTo(8);
        }

        write(writer, array[i]);
    }
}

template <typename RAW_ARRAY, ArrayType ARRAY_TYPE, typename ARRAY_TRAITS>
BitSize bitSizeOf(const Array<RAW_ARRAY, ARRAY_TYPE, ARRAY_TRAITS>& array, BitSize bitPosition = 0)
{
    BitSize endBitPosition = bitPosition;

    if constexpr (ARRAY_TYPE == ArrayType::AUTO || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
    {
        endBitPosition += bitSizeOf(fromCheckedValue<VarSize>(convertSizeToUInt32(array.size())));
    }

    for (size_t i = 0; i < array.size(); ++i)
    {
        if constexpr (ARRAY_TYPE == ArrayType::ALIGNED || ARRAY_TYPE == ArrayType::ALIGNED_AUTO)
        {
            endBitPosition = alignTo(8, endBitPosition);
        }

        endBitPosition += bitSizeOf(array[i], endBitPosition);
    }

    return endBitPosition - bitPosition;
}

} // namespace detail

template <typename RAW_ARRAY, ArrayType ARRAY_TYPE, typename ARRAY_TRAITS>
uint32_t calcHashCode(uint32_t seedValue, const Array<RAW_ARRAY, ARRAY_TYPE, ARRAY_TRAITS>& array)
{
    uint32_t result = seedValue;
    for (size_t i = 0; i < array.size(); ++i)
    {
        result = calcHashCode(result, array[i]);
    }

    return result;
}

} // namespace zserio

#endif // ZSERIO_ARRAY_H_INC
