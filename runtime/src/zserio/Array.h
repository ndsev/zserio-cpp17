#ifndef ZSERIO_ARRAY_H_INC
#define ZSERIO_ARRAY_H_INC

#include <type_traits>

#include "zserio/ArrayTraits.h"

namespace zserio
{

/**
 * Array type enum which defined type of the underlying array.
 */
enum ArrayType
{
    NORMAL, /**< Normal zserio array which has size defined by the Zserio schema. */
    IMPLICIT, /**< Implicit zserio array which size is defined by number of remaining bits in the bit stream. */
    ALIGNED, /**< Aligned zserio array which is normal zserio array with indexed offsets. */
    AUTO, /**< Auto zserio array which has size stored in a hidden field before the array. */
    ALIGNED_AUTO /**< Aligned auto zserio array which is auto zserio array with indexed offsets. */
};

template <typename RAW_ARRAY, ArrayType ARRAY_TYPE,
        typename ARRAY_TRAITS = ArrayTraits<typename RAW_ARRAY::value_type>>
class Array
{
public:
    /** Array type. */
    static constexpr ArrayType TYPE = ARRAY_TYPE;

    /** Typedef for the raw array. */
    using RawArray = RAW_ARRAY;

    /** Typedef for the value type. */
    using ValueType = typename RawArray::value_type;

    /** Typedef for allocator type. */
    using allocator_type = typename RawArray::allocator_type;

    /** Typedef for the array traits. */
    using Traits = ARRAY_TRAITS;

    /**
     * Typedef for the array's owner type.
     *
     * Owner type is needed for proper expressions evaluation. If no owner is needed for expressions evaluation,
     * detail::DummyArrayOwner is used.
     */
    using OwnerType = detail::array_owner_type_t<ValueType>;

    /**
     * Constructor from l-value raw array.
     *
     * \param owner View to the array's owner.
     * \param rawArray Raw array.
     */
    template <typename OWNER_TYPE_ = OwnerType, std::enable_if_t<!detail::is_dummy_v<OWNER_TYPE_>, int> = 0>
    explicit Array(const OwnerType& owner, const RawArray& rawArray) :
            m_owner(owner),
            m_rawArray(rawArray)
    {}

    /**
     * Constructor from l-value raw array.
     *
     * \param rawArray Raw array.
     */
    template <typename OWNER_TYPE_ = OwnerType, std::enable_if_t<detail::is_dummy_v<OWNER_TYPE_>, int> = 0>
    explicit Array(const RawArray& rawArray) :
            m_rawArray(rawArray)
    {}

    /**
     * Method generated by default.
     *
     * \{
     */
    ~Array() = default;
    Array(const Array& other) = default;
    Array& operator=(const Array& other) = default;
    Array(Array&& other) = default;
    Array& operator=(Array&& other) = default;
    /**
     * \}
     */

    /**
     * Operator equality.
     *
     * \param other Array to compare.
     *
     * \return True when the underlying raw arrays have same contents, false otherwise.
     */
    bool operator==(const Array& other) const
    {
        if constexpr (detail::has_equal_method_v<Traits>)
        {
            return std::equal(m_rawArray.begin(), m_rawArray.end(), other.m_rawArray.begin(),
                    other.m_rawArray.end(), Traits::equal);
        }
        else
        {
            return m_rawArray == other.m_rawArray;
        }
    }

    /**
     * Operator inequality.
     *
     * \param other Array to compare.
     *
     * \return True when the underlying raw arrays have different contents, false otherwise.
     */
    bool operator!=(const Array& other) const
    {
        if constexpr (detail::has_equal_method_v<Traits>)
        {
            return !operator==(other);
        }
        else
        {
            return m_rawArray != other.m_rawArray;
        }
    }

    /**
     * Operator less than.
     *
     * \param other Array to compare.
     *
     * \return True when the underlying raw array is less than the other underlying raw array.
     */
    bool operator<(const Array& other) const
    {
        if constexpr (detail::has_equal_method_v<Traits>)
        {
            return std::lexicographical_compare(m_rawArray.begin(), m_rawArray.end(), other.m_rawArray.begin(),
                    other.m_rawArray.end(), Traits::lessThan);
        }
        else
        {
            return m_rawArray < other.m_rawArray;
        }
    }

    /**
     * Gets length of the array.
     *
     * \return Length of the array.
     */
    size_t size() const
    {
        return m_rawArray.size();
    }

    /**
     * Returns element view at the given index.
     *
     * \return View to the specified element.
     */
    decltype(auto) at(size_t index) const
    {
        return Traits::at(m_owner, m_rawArray.at(index), index);
    }

private:
    OwnerType m_owner; // view to owner type, parameters are copied by value and that is ok
    const RawArray& m_rawArray;
};

} // namespace zserio

#endif // ZSERIO_ARRAY_H_INC
